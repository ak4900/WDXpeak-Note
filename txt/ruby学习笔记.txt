# -*- coding: utf-8 -*-
如果原始碼裡出現UTF-8中文，檔案第一行必須加上# encoding: utf-8

第一章：ruby 快速上手
一 DOC
（1）RDoc 现在ruby已经可以类似javadoc，从源代码生成html文档
（2）ri 类名 //在命令行下使用ri命令可以查看类名文档

二 ruby OO
ruby是完全面向对象语言，即使所有基本类型的变量都可看做对象，这样带来了描述的各种简化，
例如需要求绝对值，在java中：
int num = -1234;
num = Math.abs(numb); //=>1234
而在ruby中：
num = -1234.abs //=>1234

三 基本语法
(1)每行结束无需分号，注释以#起头
方法: def 方法名()
      	 code...
     end
调用方法时可省略括号：如 puts 1234等同于puts(1234)

(2)字符串使用单引号和双引号的区别：使用单引号效率更好；使用双引号ruby背后会做些替换之类的工作，例如\n会变成换行，第二个用处是可以在双引号中直接镶嵌变量
name = eric
"fuck you #{name}" //=> fuck you eric

(3)ruby变量的定义方法
一般变量:name
成员变量：@name
类变量（静态变量）:@@name
全局变量:$name
类名:Name,MyClass(大写开头，驼峰标识)
常量：全大写 FUCK

(4)数组与hashes:
数组是索引数组：
a = [1,'a',3.14]
a[2]//=> 3.14
hashes是关联数组：
inst_section = {
'cello' => 'string',
'clarinet' => 'woodwind',
'drum' => 'percussion',
'oboe' => 'woodwind',
'trumpet' => 'brass',
'violin' => 'string'
}
inst_section['cello'] //=> woddwind

(5)symbol 类枚举用法
有些想指明为唯一值的标志型变量，如东南西北 east south west north,在ruby中可以直接以分号开头去声明，然后ruby保证该变量的唯一性
这个通常用在hashes的key中保证key的值是唯一
如上面hashes的例子就可以变成：
inst_section = {
:cello => 'string',
:clarinet => 'woodwind',
......
}
使用时：inst_section[:cello] //=>woddwind
symbol不是string:inst_section['cello']  //=>nil

ruby 1.9的新语法，在hashes中直接用 key:value声明则直接可以用symbol作为键值
如
inst_section = {
cello:'string',
clarinet:'woodwind'
}
使用：inst_section[:cello] //=>woddwind

（6）流程控制语句 if while for
ruby不用大括号，用end 来表示语句完结
if:
if today.saturday?
puts "Do chores around the house"
elsif today.sunday?
puts "Relax"
else
puts "Go to work"
end

注意elsif写法，不是elseif

while:
num_pallets = 101
weight = 1
while weight < 100 and num_pallets <= 30
      pallet = next_pallet()
      weight += pallet.weight
      num_pallets += 1
end

支持的另外一种 if 和 while的写法（类似perl）：
执行的语句 if 条件
执行的语句 while 条件

（7）regexp 正则表达式
ruby的正则表达式形式（和javascript相似）： /xxx/
用 =～去验证是否匹配字符串，如果匹配，会返回第一个匹配的字符串的下标位置，如果不匹配则返回nil
if time =~ /\d\d:\d\d:\d\d/
  puts "is time!!"
end

替换：
sub(正则,字符串) 
gsub(正则，字符串) #贪心模式
newline= line.sub(/Perl/, 'Ruby')# replace first 'Perl' with 'Ruby'
newerline = newline.gsub(/Python/, 'Ruby') # replace every 'Python' with 'Ruby'

（8）block 代码块
::在大括号或者 do end 之间的代码快
{puts "fuck block"}
或
do
  "fuck block"
  "fuck bolck2"
end

::单行用{};多行用 do end

::调用时，直接跟在方法调用后面
例如 greet(方法本来的参数) {puts "fuck"}

::yield:放在方法的代码块内，可看作是调用了之后传进来的block代码块
例子：
def call_block
  puts "Start of method"
  yield
  yield
  puts "End of method"
end
call_block { puts "In the block" }
#produces:
#Start of method
#In the block
#In the block
#End of method

::yield可以传参数到block里的变量，block里面的变量用|xxx|接收参数，例如yield('fuck'),{|xxx| puts xxx} //xxx=> fuck
def who_says_what
  yield("Dave", "hello")
  yield("Andy", "goodbye")
end
who_says_what {|person, phrase| puts "#{person} says #{phrase}"}
produces:
Dave says hello
Andy says goodbye

::block的用途，ruby本身的lib就用block去实现遍历（iterator）
animals = %w( ant bee cat dog elk )# create an array
animals.each {|animal| puts animal }# iterate over the contents

[ 'cat', 'dog', 'horse' ].each {|name| print name, " " }
5.times { print "*" } #对象5 调用了5次 block
3.upto(6) {|i| print i }#对象3 直到加到6 ，会print出每次增加到的数
('a'..'e').each {|char| print char } #遍历字母a到e的每个字母

四.IO基础
（1）print 不换行； puts 换行 ；p 换行，但是打印数组时会以[xx，xx]的形式打出,输出对象也用P比较好
（2）printf//参照C语言
printf("fuck that %s",'fuck you too'); //=> fuck that fuck you too
(3)gets 每次读一行，读到尾返回nil

五.命令行模式
（1）ruby运行脚本时接收参数
方法一：使用内置变量 ARGV,ARGV是一个数组，可用ARGV.size ARGV[1]等方法
方法二：使用ARGF,ARGF更为特殊，用于传入文件目录，ARGF会自动遍历好目录下的文件

--------------------------------------------------------------------------------------
第二章 ： 类  对象 变量
（1）对象定义：
：：成员变量前要加@,实际@xxx才是完整的成员变量名称
：：initialize()是构造方法
：：to_s是 相当于JAVA toString方法
：：attr_reader ，ruby提供的便利属性get方法，后面用:属性名，该属性就可以用 类名.属性 的形式访问，若多个，使用逗号隔开(:a,:b,:c)
：：attr_writer ，set方法，后面用 :属性名 表示该属性可以 用 类名.属性=新值 
：：attr_accessor ，get与set方法
class BookInStock
  attr_reader :isbn
  attr_accessor :price

  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end

  def to_s
    "ISBN: #{@isbn}, price: #{@price}"
  end

end


（2）对象里的虚拟属性（实际上是一个方法后加等于号，用户用上去就好像在使用属性一样）
class Man 
  attr_reader :age

  def initialize(age) 
    @age = age
  end

  def ageForWoman
    @age/2
  end

  def ageForWoman=(age)
    @age = age-10
  end 
end

man = Man.new(50)
p man.age #50
p man.ageForWoman #25
man.ageForWoman=30 
p man.ageForWoman #10

：：这样看上去，感觉就像在设置一个Man.ageForWoman的属性一样，但是实际上这是一个方法，可以用attr_xxx代替这种写法

（2.1）类方法（类似静态方法）
三种写法
a)def 类名.方法名
b)写在类外面，肯定不用
c)def self.方法名

（2.2）类常数
Version = '1.0'
外部用 类名::Version 访问

（2.3）类变量
@@变量名 就是定义了类变量，类外部要访问类变量的话要用写方法访问

(3)包引入
require 'csv' #引入ruby自身的lib
require_relative 'xxx_fuck' #引入同一个目录下的xxx_fuck.rb文件

(4)权限控制（两种书写方式）
:::1
class MyClass
  def method1
    #...
  end  # default is 'public'

  protected
  def method2
    #...
  end  # subsequent methods will be 'protected'

  private
  def method3
    #...
  end # subsequent methods will be 'private'

  public
  def method4
    #...
  end
end

:::2
class MyClass
  def method1
  end

  def method2
  end
  # ... and so on

  public :method1, :method4
  protected :method2
  private :method3
end

(5)对象 变量
person = Person.new
person1 = person
：：可用 person.class找到对象变量所属的class
：：可用 person.object_id 找到对象的 hashcode？
：：ruby里的每一个对象变量都不是一个object，只是一个引用或指针，指向同一个heap里面的对象，这里person1也指向了person指向的heap里面的对象
：：freeze方法，冻结对象，例如person.freeze后，也指向person的person1就不能修改这个对象
：：dup方法，复制对象,例如 person2 = person.dup,那么person2 就是全新的一个指向对象

（6）方法的返回值
没有return的时候，方法里最后一行的表达式所得值将会作为返回值

（7）方法到方法的参数
有时我们一个方法内调用另外一个方法，对于传入的参数不需要太多的了解就可以用 *args作为参数传入
def method1(*args) 
  method2(*args)
end

(8)respond_to? 可以检查一个对象有没有这个方法(消息，变量)
eric = Dog.new
eric.respond_to?('wo')
#要注意respond_to?方法不能识别method_missing所创建的方法,因此每当使用method_missing的时候都要重写respond_to?方法

--------------------------------------------------------------------------------------
第三章 ： 容器 块 遍历器(containers blocks iterators) proc lambda
(1) 数组
::创建数组的两种方法，一是直接[]，二是使用Array.new

::读取数组也有多总方法 例有数组 a= ['x','y','z']
正序获取: a[0] # 'x'
到序获取: 倒数第一个由-1开始 a[-1] # => 'z'
范围获取：a[1..3] 获取下表1到3； a[1...3]获取下标1到2（不包括3）； 还可以a[-3..-1] a[4..-2]; a[start,count]从起始位置获取多少个

::%w 元素都是字符串的时候，可以用%w创建数组,如 %w(你妈 我妈 他妈 她妈)

::数组写入：a[1,2]='cat' 表示，从第一个位置开始，往后的两个下标的值用cat代替 ，例子说话吧
  a = [ 1, 3, 5, 7, 9 ]→ [1, 3, 5, 7, 9]
  a[2, 2] = ’cat’→ [1, 3, "cat", 9]
  a[2, 0] = ’dog’→ [1, 3, "dog", "cat", 9]
  a[1, 1] = [ 9, 8, 7 ]→ [1, 9, 8, 7, "dog", "cat", 9]
  a[0..3] = []→ ["dog", "cat", 9]
  a[5..6] = 99, 98 →["dog", "cat", 9, nil, nil, 99, 98]

::把数组作为stack使用
stack = []
stack.push "red"
stack.push "green"
stack.push "blue"
p stack
puts stack.pop
puts stack.pop
puts stack.pop
p stack
produces:
["red", "green", "blue"]
blue
green
red
[]

::数组作为队列（FIFO）使用
queue = []
queue.push "red"
queue.push "green"
puts queue.shift
puts queue.shift
produces:
red
green

::first()和last() 获取数组里面的头几个或最后几个的元素，返回数组，同时不会更改原数组里面的内容
array = [ 1, 2, 3, 4, 5, 6, 7 ]
p array.first(4)
p array.last(4)
produces:
[1, 2, 3, 4]
[4, 5, 6, 7]

::inspect !!
arr.inspect #=>可以转换成字符串输出,输出成"[1,2,3]"

::数据结构的总结
前端操作：放入unshift 取出shift 读取first
后端操作：放入push 取出pop 读取last

（2）hashes (associat array关联数组，maps，字典)
使用{}
：：一般情况下的hashes定义
h = { 'dog' => 'canine', 'cat' => 'feline', 'donkey' => 'asinine' }
h['dog'] # => canine

：：使用symbol(唯一键)
h = { dog: 'canine', cat: 'feline', donkey: 'asinine' }
# same as...
h = { :dog => 'canine', :cat => 'feline', :donkey => 'asinine' }
h[:dog] #=>canine

::两个字符串方法 downcase变小写; str.scan(/[\w']+/) 把str用正则匹配后返回一个数组

::Hash.new(0),用这种方式创建hash的话，所有的值都是0，方便用于计算

::sort_by (排序hash)
用法： hash.sort_by {|key,value| key or value} 用hash里面的key或者value排序，排序后返回数组，数组每个元素是一个[key,value]的数组
自己写的示例小程序
a = {
  'a'=>50,
  'b'=>20,
  'c'=>500,
  'd'=>1000,
  'e'=>10
}

arr = a.sort_by {|word,count| count}
p arr #输出:[["e", 10], ["b", 20], ["a", 50], ["c", 500], ["d", 1000]]

(3)遍历
  hash或者array.each {|each| 代码..} ；
::collect 或 map
这两个方法是遍历的同时，block里面的表达式返回值取代当前遍历的元素，常用!!

::遍历文本时可以使用 each_with_index 获得行号
  例如
  linestr.each_with_index {|line,index| puts "#{index}:#{line}"}
  each_with_index #出来的结构是|[key,valueue],index]

::inject 用于计算,内部原理是先实现each遍历然后再用参数的符号去运算
[1,3,5,7].inject(:+) # => 16
[1,3,5,7].inject(:*) # => 105

:: Enumerator去遍历 to_emu each返回emu
a = [ 1, 3, "cat" ]
h = { dog: "canine", fox: "vulpine" }
# Create Enumerators
enum_a = a.to_enum #或者 a.each也能返回enum对象
enum_h = h.to_enum
enum_a.next # 1
enum_h.next # [:dog, "canine"]
enum_a.next # 3
enum_h.next # [:fox, "vulpine"]

::each_char 遍历字符串
result = []
"cat".each_char.each_with_index {|item, index| result << [item,index] }
result # => [["c", 0], ["a", 1], ["t", 2]]

::其他用法
enum = "cat".enum_for(:each_char)
enum.to_a # => ["c", "a", "t"]

enum_in_threes = (1..10).enum_for(:each_slice, 3)
enum_in_threes.to_a # => [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]

::enum对象可以在new时传入block，这些代码不会马上运行，而会在你往后使用这个对象的代码时候运行
triangular_numbers = Enumerator.new do |yielder|
    number = 0
    count = 1
    loop do
      number += count
      count += 1
      yielder.yield number
    end
end
5.times { puts triangular_numbers.next } # 1 3 6 10 15

#其他常用数组集合方法!!!#
select {|a| a.length == 0} #需要集合中元素长度==0的才能留下
reject {|a| a.length == 0} #与上面相反，集合==0的就不要
inject {|n,i| n*i} #n是当前这个元素，i是下一个元素，这个意思是整个集合这个元素*下一个元素
join(',') #把数组每个元素用,链接起来并且返回str
delete_at(下标) #可以删除下标位置的元素

(4)块 闭包 block proc lambda
::在{}或者 do end之间，可以把它想象成匿名方法，在使用时想象成是一个额外的参数,巨大的作用是：把原来函数里一些变量可以带出函数外用，函数功能动态扩展

::block内可以读取block外的变量并改写，所以要注意变量名的问题
  1.9里头，只要在||中定义可能会有重名的变量时，前面加个分号，就表明这个是闭包的变量
例如 
square = "some shape"
sum = 0
[1, 2, 3, 4].each do |value; square|
    square = value * value # this is a different variable
    sum += square
end
puts sum
puts square
produces:
30
some shape

::在函数内使用 yield 值 可以传参数给block
fabonaci 数列的block实现方法：
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
def fib_up_to(max)
  i1, i2 = 1, 1# parallel assignment (i1 = 1 and i2 = 1)
  while i1 <= max
    yield i1
    i1, i2 = i2, i1+i2
  end
end
fib_up_to(1000) {|f| print f, " " }
puts
produces:
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

:: yield 同时也可以接收block返回的参数
自己写的
def testYield(num)
   if(yield num)
     '大于等于100'
   else
     '小于100'
   end
end

puts testYield(10) {|num| num*num>=100} #如果传进来的数相乘大于等于100，表达式会返回给 yield num的结果（true或者false），然后再执行条件语句

:: 函数中判断 调用函数时是否有使用block
使用block_given?

::block可以存储起来用变量去使用，在方法参数使用&符号的参数，代表接收一个block
class ProcExample
  def pass_in_block(&action)
    @stored_proc = action
  end
  def use_proc(parameter)
    @stored_proc.call(parameter)
  end
end
eg = ProcExample.new
eg.pass_in_block { |param| puts "The parameter is #{param}" }
eg.use_proc(99)
produces:
The parameter is 99
#上面的例子就是先把一个block传进对象变量里，然后用call可以调用
#!!proc对象前再加回一个&的话，又变回一个块,可以传送到其他地方

::写一个中间类来存储block的例子（block威力：可用在动态代码处理）
def create_block_object(&block)
  block
end
bo = create_block_object { |param| puts "You called me with #{param}" }
bo.call 99
bo.call "cat"
produces:
You called me with 99
You called me with cat

::用变量装的block对象其实都是Proc对象
直接用lambda{代码...}也能返回proc对象
    1.9里面的新写法 -> args {}
proc1 = -> arg { puts "In proc1 with #{arg}" }
proc2 = -> arg1, arg2 { puts "In proc2 with #{arg1} and #{arg2}" }
proc3 = ->(arg1, arg2) { puts "In proc3 with #{arg1} and #{arg2}" }

::参数里型餐用*变量名代表往后的多个参数
例:
proc1 = lambda do |a, *b, &block|
  puts "a = #{a.inspect}"
  puts "b = #{b.inspect}"
  block.call
end

proc1.call(1, 2, 3, 4) { puts "in block1" }
produces:
a = 1
b = [2, 3, 4]
in block1

::lambda 和 proc 差别对比
（1）在proc里头使用return,会令方法也return，方法里面的yield下面的语句就不能执行
lambda中的return则只会返回lambda，对定义或使用lambda的函数不会返回

（2）yield 或 call 传参数时，proc对参数接收能力更好，当实参个数与形参个数不同时，proc会自己调整，而lambda则必须参数一一对应

：：闭包
把闭包简单理解成"定义在一个函数内部的函数"。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。


#grep方法#
用法: 容器.grep(/正则匹配/) {|匹配到的元素| 执行处理}
%w(fuck duck huck).grep(/uck/) {|a| p a+$1} #$1是前面正则表达式第一个括号匹配到的串
--------------------------------------------------------------------------------------
第四章 ： 继承 模块 接口 （inheritance module mixin） 
(1)继承
：：定义子类时，用 < 父类 表示extends self变量相当与当前对象（类似java的this）
代码：
class Parent
  def say_hello
    puts "Hello from #{self}"
  end
end
p = Parent.new
p.say_hello

class Child < Parent # Subclass the parent...
end
c = Child.new
c.say_hello
produces:
Hello from #<Parent:0x0000010086b220>
Hello from #<Child:0x0000010086b108>

：：子类对象.superclass #=>父类 ；还可以用 子类.is_a?(父类)判断

：：所有类的最终父类都是object，1.9中，object.superclass是BasicObject,那是为了方便元编程

(2)Moduel 模块
：：模块不能建立实例，模块不能被继承，模块提供namepace防止各种重名问题，模块也支持mixin

：：模块 函数定义时 用 模块名.函数名去定义
module Trig
  PI = 3.141592654
  def Trig.sin(x)
    # ..
  end
  def Trig.cos(x)
    # ..
  end
end

：：先require文件 使用模块时，用 模块名.方法名 去访问方法，用 模块名::常量名 去访问常量
require_relative 'trig'
y = Trig.sin(Trig::PI/4)


（3）mixin（就是把module混进类里面，类似接口作用)
::先来个例子 在模块定义一个方法后，在类里面 include 这个模块进去后，类的实例对象可以直接使用这个方法
module Debug
  def who_am_i?
    "#{self.class.name} (id: #{self.object_id}): #{self.name}"
  end
end

class Phonograph
  include Debug
  attr_reader :name
  def initialize(name)
    @name = name
  end
end
ph = Phonograph.new("West End Blues")
ph.who_am_i? # => "Phonograph (id: 2151894340): West End Blues"

::module 比接口更优的是可动态修改，使得include这个module的类和对象可以动态改变行为

::一个导入Enumerable模组然后，重写each的例子
class VowelFinder
  include Enumerable
  def initialize(string)
    @string = string
  end
  def each
    @string.scan(/[aeiou]/) do |vowel|
      yield vowel
    end
  end
end

vf = VowelFinder.new("the quick brown fox jumped")
vf.inject(:+) # => "euiooue"

::注意module里面方法可能与类里面方法重名的情况，ruby会优先使用类本来的定义的方法

::多用module，少用继承，降低耦合

思考：java里面的interface是先定义一套标准，然后在实现类里头重写这套标准，编程时直接使用接口，具体要用哪种功能就指向哪个实现类；ruby里面是先把所有的实现功能写在module里头，然后要有某种功能的类直接include相应的module，编程的时候不会脱离class。暂时觉得编程层面ruby的方式更好，但是文档的角度来说module令结构变得更复杂
--------------------------------------------------------------------------------------
第五章 ：基本类型 (num string range regularExpression)
（1）num
123456
0d123456 #十进制
123_456 
-543
0xaabb #16进制 0b是二进制

::str to num
Integer('1') # => 1

::num运算
1 + 2#=> 3
1 + 2.0 #=> 3.0
1.0 + Complex(1,2)#=> (2.0+2i)
1 + Rational(2,3) #=> (5/3)
1.0 + Rational(2,3) #=> 1.6666666666666665

1.0 / 2 # => 0.5
1 / 2.0 # => 0.5
1 / 2 # => 0

::使用 require 'mathn' 可令除法不以小数点方式计算，以分式计算

::num一些叠加计算
3.times { print "X" }
1.upto(5) {|i| print i, " " }
99.downto(95) {|i| print i, " " }
50.step(80, 5) {|i| print i, " " }
produces:
X X X 1 2 3 4 5 99 98 97 96 95 50 55 60 65 70 75 80

::次方 **
2**3 = 8

::开方
Math.sqrt(9) = 3

::小数点后取两位
f=6.3333  
format("%.2f",f).to_f #6.33 

::绝对值
-5.abs = 5

::去小数
1.333.round = 1



（2）String
::单引号可以镶嵌双引号，两个反斜杠转义成一个
'escape using "\\"' # => escape using "\"
'That\'s right' # => That's 

 :: 双引号内使用 #{}可以在内面执行运算表达式
"Seconds/day: #{24*60*60}" # => Seconds/day: 86400
"#{'Ho! '*3}Merry Christmas!" # => Ho! Ho! Ho! Merry Christmas!
"Safe level is $SAFE" # => Safe level is 0

::使用%Q{}和%q|| 之间的字符代表是被双引号和单引号包括了

::string.strip 类似java里面trim的用法，消除两边空格

::字符串链接，可以用+ <<和concat()，用后两个效率更高
和concat
#justfor show

::字符串变字符数组 用str.split(//s)是英文，UTF8中文用 str.split(//u)

::使用chomp! 删除换行符

::string多行字符串的写法，使用 #注意<<后面不能有空格EOF可以是其他字符，'EOF'也可以
str =<<-EOF
    <div>fuck<div>
    <a href="fun">fun</a>
EOF

（3）range 范围
::两个点包含last，三个点不包含
1..10
'a'..'z'
0..."cat".length

::range可以用to_a方法转换成array，可以用to_enum方法转换成enumerator

::一些 range常用方法
digits = 0..9 
digits.include?(5)  #=>  true 包含吗？
digits.min #=> 0 最小值
digits.max #=> 9 最大值
digits.reject {|i| i < 5 } #=>  [5, 6, 7, 8, 9] 除了小于5的
digits.inject(:+) #=> 45 

::case and when 配合range的用法
car_age = gets.to_f
# let's assume it's 5.2
case car_age
when 0...1
  puts "Mmm.. new car smell"
when 1...3
  puts "Nice and new"
when 3...6
  puts "Reliable but slightly dinged"
when 6...10
  puts "Can be a struggle"
when 10...30
  puts "Clunker"
else
  puts "Vintage gem"
end
produces:
Reliable but slightly dinged

--------------------------------------------------------------------------------------
第六章 ：正则表达式

正则使用/xxxx/xx 的形式 创建用Regexp.new(/xxx/)或直接/xxx/ 或 %r{xxx}

::测试字符串是否match用str=~// 或者 //～=str 成功返回匹配的位置值，失败返回nil

::！～这个是不匹配 
put line if line !~ /on/ #line里面没有on的话就输出

::替换 sub(//,替换的str);gsub,sub的贪婪模式，所有匹配都会替换;sub和gsub都会返回新string
a = "cat and dog"
newa = str.sub(/cat/,'baby')
puts newa #=> baby and dog

::sub 和 gsub后面可以接收 block参数，yield出来的就是match到的字符
a = "quick brown fox"
a.sub(/^./) {|match| match.upcase } # => "Quick brown fox"
a.gsub(/[aeiou]/) {|vowel| vowel.upcase } # => "qUIck brOwn fOx"

::sub后面替换的参数可以用组pattern取代
puts "fred:smith".sub(/(\w+):(\w+)/, '\2, \1') # => simth, fred
puts "nercpyitno".gsub(/(.)(.)/, '\2\1') #=>enrcpyitno

::scan像gsub，会找到所有匹配的字符串，但是不会更改，只会把他们提取出来返回数组

::想在原数组上更改，使用sub!或者gsub! 但是如果原字符串没有匹配到，会返回nil

:: 跟在正则后面的各种参数
i 大小写忽略;o 只匹配一次;m .号不匹配换行；x 复杂模式，很长的正则里面，不会匹配空格和换行

:: match方法,//.match(str) 成功时返回一个MatchData对象，失败时候返回nil
name = 'Fats Waller'
/a/.match(name)#=> #<MatchData "a">

::MatchData对象 的一些方法:
pre_match 返回匹配字符的前面部分字符串
MatchData[0] 返回匹配到的字符
post_match 返回匹配字符的后面分字符串

::关键符和大多数其他的语言都一样 \s \d \w . * ? + ^ $ []{m,n} 等等

::group访问 #{MatchDate对象[第几个]},注意从1开始
md = /(\d\d):(\d\d)(..)/.match("12:50am") 
"Hour is #{md[1]}, minute #{md[2]}"  # => "Hour is 12, minute 50"

::组引用
show_regexp('Mississippi', /(\w+)\1/) # => M->ississ<-ippi


::正则高级应用，利用组函数 str =~ /()()/ [$1,$2],匹配好后会返回一个对应[$1,$2]的数组 
例:
date = "12/25/2010"
date =~ %r{(\d+)(/|:)(\d+)(/|:)(\d+)}[$1,$2,$3,$4,$5] # => ["12", "/", "25", "/", "2010"]
date =~ %r{(\d+)(?:/|:)(\d+)(?:/|:)(\d+)}[$1,$2,$3] # => ["12", "25", "2010"]

::match只能匹配一个,ruby没有//g这种用法，可以使用scan，scan会返回一个匹配成功的数组
"abcabcabz".scan(%r{abc}).each {|item| puts item} # 输出2行abc

--------------------------------------------------------------------------------------
第七章 方法 函数的更多应用
::方法的预定义参数 (和PHP一样)，有传入则用实参的值，没有则用预定义的值
def cool_dude(arg1="Miles", arg2="Coltrane", arg3="Roach")
"#{arg1}, #{arg2}, #{arg3}."
end

::并且参数可以互相依赖写表达式
def surround(word, pad_width=word.length/2)
"[" * pad_width + word + "]" * pad_width
end

::模糊参数 可以用一个*变量 接收后面的或所有的参数
def varargs(arg1, *rest) #后面无论传入多少个参数都会设进rest的数组里面
"arg1=#{arg1}. rest=#{rest.inspect}"
end
另一个用法，例如直接使用父类的方法，可以不管扔进的什么参数，直接扔给父类
class Child < Parent
  def do_something(*not_used)
    # our processing
    super
  end
end

::1.9版本，模糊参数可以放到参数组的任何地方
def split_apart(first, *splat, last)
  puts "First: #{first.inspect}, splat: #{splat.inspect}, " +
    "last: #{last.inspect}"
end

::方法的最后一个参数可以用 &符号+变量，表明这个参数是一个block，并可以把这个block存储起来
class TaxCalculator
  def initialize(name, &block)
    @name, @block = name, block
  end
  def get_tax(amount)
    "#@name on #{amount} = #{ @block.call(amount) }"
  end
end
tc = TaxCalculator.new("Sales tax") {|amt| amt * 0.075 }
tc.get_tax(100) # => "Sales tax on 100 = 7.5"
tc.get_tax(250) # => "Sales tax on 250 = 18.75"

::类里面调用方法时不写明调用者，默认使用self，就是对象本身

::所有的方法都会返回参数，当你没有写return时候，方法里面最后一条表达式的值就是返回值

::1.9在传参的时候也可以使用 *[]作为模糊参数，十分方便
def five(a, b, c, d, e)
"I was passed #{a} #{b} #{c} #{d} #{e}"
end
five(1, 2, 3, 4, 5 ) #=>"I was passed 1 2 3 4 5"
five(1, 2, 3, *['a', 'b']) #=>下面的如此类推，总之能够传进来
five(*['a', 'b'], 1, 2, 3)
five(*(10..14))
five(*[1,2], 3, *(4..5))

::匹配最短结果（不贪婪）用?
.*? 0次以上最短匹配
.+? 1次以上最短匹配

--------------------------------------------------------------------------------------
第八章 表达式 妙用
::链式表达式
a = b = c = 0 # => 0
[ 3, 1, 7, 0 ].sort.reverse # => [7, 3, 1, 0]

::if 或者 case 的确认分支最后一个表达式可以作为返回值
例
song_type = if song.mp3_type == MP3::Jazz
              if song.written < Date.new(1935, 1, 1)
                Song::TradJazz
              else
                Song::Jazz
              end
            else
              Song::Other
            end

rating = case votes_cast
         when 0...10 then Rating::SkipThisOne
         when 10...50 then Rating::CouldDoBetter
         else Rating::Rave
         end

::每一个运算符可以看成是一个方法，例如a*b可以看作 a执行*这个方法，传入b这个参数
a, b, c = 1, 2, 3
a * b + c # => 5
(a.*(b)).+(c) # => 5

::由于符号都可以是一个object，你可以在自己的类里面定义各种符号的运算（像C++）
class ScoreKeeper
  def initialize
    @total_score = 0
    @count = 0
  end
  def <<(score)
    @total_score += score
    @count += 1
    self
  end
  def average
    fail "No scores" if @count == 0
    Float(@total_score) / @count
  end
end
scores = ScoreKeeper.new
scores << 10 << 20 << 40
puts "Average = #{scores.average}" #=>23.333333333 这个例子是每次调用完<<之后都会把当前对象返回除去，所以可以<<23<<30链式调用

::重写[]符号的例子，当使用时 对象[参数1，参数2]=值，在方法里头会把值作为最后一个参数传入
class SomeClass
  def []=(*params)
    value = params.pop
    puts "Indexed with #{params.join(', ')}"
    puts "value = #{value.inspect}"
  end
end
s = SomeClass.new
s[1] = 2
s['cat', 'dog'] = 'enemies'
produces:
Indexed with 1
value = 2
Indexed with cat, dog
value = "enemies"

::！！！！调用底层操作系统的命令行！！！！
使用``反单引号或者%x{命令}可以执行系统命令！
‘date‘ # => "Tue Nov 9 18:45:39 CST 2010\n"
‘ls‘.split[34] # => "foreword3.pml"
%x{echo "hello there"} # => "hello there\n"

可以把参数变量传入系统命令！！同样是在反单引号里面使用#{}
for i in 0..3
  status = ‘dbmanager status id=#{i}‘
    # ...
end

::方法= 的类型中现在ruby只会返回存入参数，不会理会return
class Test
  def val=(val)
    @val = val
    return 99
  end
end
t = Test.new
a = (t.val = 2)
a # => 2

::在ruby中，交换两个数的值不用中间变量
a = 1
b = 2
a, b = b, a #=> b=1 a=2

::一些小语法糖果
a = 1, 2, 3, 4 # a=[1, 2, 3, 4]
b = [1, 2, 3, 4] # b=[1, 2, 3, 4]
a, b = 1, 2, 3, 4 # a=1, b=2
c, = 1, 2, 3, 4 # c=1
a, b, c, d, e = *(1..2), 3, *[4, 5] # a=1, b=2, c=3, d=4, e=5
a, *b = 1, 2, 3 # a=1, b=[2, 3]
a, *b = 1 # a=1, b=[ ]
*a, b = 1, 2, 3, 4 # a=[1, 2, 3], b=4
c, *d, e = 1, 2, 3, 4 # c=1, d=[2, 3], e=4
f, *g, h, i, j = 1, 2, 3, 4 # f=1, g=[ ], h=2, i=3, j=4
first, *, last = 1,2,3,4,5,6 # first=1, last=6

::ruby没有++ --，用+=和-=就好啦

::ruby里面 除了nil和false之外，一切对象都是true

::&&的优先级比||要高

::||=的作用，
a ||= 123 # 如果a没有值，它会被设成123，如果有了则不变

::defined? 后面跟一个任意object，如果该object有意义，则会返回一个描述，否则会返回nil

::有三目运算符的啦 cost = duration > 180 ? 0.35 : 0.25

::case 值
 when 范围
 else 以外
 end 

::while end

::until条件 then  end （与while相反，条件取反时才做）

::做几次
3.times do
print "fuck fuck fuck"
end

::each
[1,2,3].each{|e|
p e
}

::for..fn
for xx in 集合{
    循环要做的事
}

::break redo（当前条件循环再执行一次） next（相当于continute跳过这次循环）

(2)变量的范围
在block内定义的变量，外部不能访问，除非变量之前就存在于外部

::ruby1.9引入了block-local变量的概念，在block参数前面加分号，则这个变量即使在block域外定义了，也不会影响到block域外的值
例:
square = "yes"
total = 0
[ 1, 2, 3 ].each do |val; square|
    square = val * val
    total += square
end
puts "Total = #{total}, square = #{square}"
produces:
Total = 14, square = yes

--------------------------------------------------------------------------------------
第九章 Exception catch throw
(1)自写expection类要集成StandardError

(2)exception 格式，使用begin rescue和and，rescue后跟exception名称，代码里面的$!全局变量是一个例外对象，raise相当与throw可以引发例外,ensure相当与finally(无论如何都要执行的语句)
require 'open-uri'
page = "podcasts"
file_name = "#{page}.html"
web_page = open("http://pragprog.com/#{page}")
output = File.open(file_name, "w")
begin
  while line = web_page.gets
    output.puts line
  end
  output.close
rescue Exception
  STDERR.puts "Failed to download #{page}: #{$!}"
  output.close
  File.delete(file_name)
  raise
ensure
  puts "fuck exception"
end

::你也可以不用$!变量，在rescue Exception=>bang 使用变量名，bang将会成为例外变量

::exception变量的一些方法 $!.message，输出例外信息；$!.backtrace 输出例外位置（等同与$@变量）

::retry写在rescue里面可以重新执行begin里面的语句，例如可以要她 sleep 10秒然后再执行回begin的语句

::rescue其实类似if语句，例如前面的语句发生例外，就可以执行后面的值，有时可以用来设定默认值
v = Integer(val) rescue 5 #如果传入的val是int类型，发生例外就取默认值5

::如果整个方法里面都是以begin end结尾的话，begin end可以省略

(3)raise
raise  # 会抛一个runtime error
raise 'message' #抛出错误信息
raise Exception类 #直接抛出错误类
raise 类 '信息' caller #抛出完整的异常

（4）catch throw 有时遇到某种情况，例如会重大伤害到数据，就可用于跳出循环或离开语句
word_list = File.open("wordlist")
word_in_error = catch(:done) do
result = []
while line = word_list.gets
  word = line.chomp
  throw(:done, word) unless word =~ /^\w+$/
  result << word
end
puts result.reverse
end
if word_in_error
  puts "Failed: '#{word_in_error}' found, but a word was expected"
end
produces:
Failed: '*wow*' found, but a word was expected  #result的值不会被执行

--------------------------------------------------------------------------------------
第十章 IO
所有的IO类都是从File或者BasicSocket继承而来

（1）读取文件
file = File.open("filename","权限符") 
file = File.join(Rails.root,'config','weibo.yml') #!!这样可以方便读取路径+文件
file.close
::权限符跟php一样，有r(默认) r+（读写） w（只写，清空原有数据） w+（读写，清空原有数据，不存在文件则创建） a（只写，后面追加） a+ （读写，后面追加） b（读二进制文件）

::和File.new不同，File.open()后面可以使用block，参数就是这个file对象，并且block代码运行完之后可以自动关闭对象，new则不行

#file对象存取主要用IO类里面的方法

::逐个字符读出 file.each_byte
File.open("testfile") do |file|
  file.each_byte.with_index do |ch, index|
    print "#{ch.chr}:#{ch} "
    break if index > 10
  end
end
produces:
T:84 h:104 i:105 s:115 :32 i:105 s:115 :32 l:108 i:105 n:110 e:101

::file.each_line(){|line|} ，逐行读，也可以使用参数，遇到参数这个字符就自动换行
File.open("testfile") do |file|
  file.each_line("e") {|line| puts "Got #{ line.dump }" }
end
#也可以使用each_line.with_index {|line,index| do xxx}

::可以直接用IO这个类把一个文件读入一个string或者array
# read into string
str = IO.read("testfile")
str.length # => 66
str[0, 30] # => "This is line one\nThis is line "
# read into an array
arr = IO.readlines("testfile")
arr.length # => 4
arr[0]# => "This is line one\n"

(2)写入文件
::十分简单，用file资源puts就可以写入到文件
File.open("output.txt", "w") do |file|
  file.puts "Hello"
  file.puts "1 + 2 = #{1+2}"
end

::写入二进制码（三种方法）
str1 = "\001\002\003" # => "\x01\x02\x03"
str2 = ""
str2<< 1 << 2 << 3# => "\x01\x02\x03"
[ 1,2, 3 ].pack("c*") # => "\x01\x02\x03"

(2.1)其他操作
::File.rename("before.txt","after.txt")

::复制粘贴，用fileutils包方便
require 'fileutils'
FileUtils.cp("from","to")
FileUtils.mv("from","to")
.pwd() #查看当前目录
.ln_s() #剩下的方法跟linux类似
.chmod()
.rm()
.mv()

::删除 File.delete("filename")

::目录Dir，和File一样，open时直接使用区块就不用创建对象不用close
Dir.open('/usr/bin'){|dir| #dir就是内建block对象，block执行完后变量自动消除
  dir.each{|name|
    puts name
  }
}

#!!把目录下的所有目录名称和文件获取成一个数组
Dir.glob("#{Rails.root}/app/*")

（3）网络IO，各种类 UDPSocket TCPSocket等等
::tcp
require 'socket'
client = TCPSocket.open('127.0.0.1', 'www')
client.send("OPTIONS /~dave/ HTTP/1.0\n\n", 0) # 0 means standard packet
puts client.readlines
client.close

::http
require 'net/http'
http = Net::HTTP.new('www.pragprog.com', 80)
response = http.get('/titles/ruby3/programming-ruby-3')
if response.message == "OK"
  puts response.body.scan(/<img alt=".*?" src="(.*?)"/m).uniq[0,4]
end

::注意lib下面的net/包，还有ftp pop stmp等各种协议提供使用

::使用open-uri读取网页
require 'open-uri'
page = open('www.163.com').read
if page =~ %r{<title>(.*?)</title>} #使用正则读出标题
  puts "Title is #{$1.inspect}"
end

::使用强大的hpricot库去方便读取http的各种标签（需要用gem安装）
require 'open-uri'
require 'hpricot'
page = Hpricot(open('http://pragprog.com'))
puts "Page title is " + page.at(:title).inner_html
# 将div id=copyright的p读出来
puts page.at('div#copyright p')
# 将第二条超链接读出来
puts "\nSecond hyperlink is"
puts page.at('div#site-links a:nth(2)')
produces:
Page title is The Pragmatic Bookshelf
<p>
Copyright &copy; 1999&#8211;2010 The Pragmatic Programmers, LLC.
</p>  
Second hyperlink is
<a href="http://pragprog.com/community">Connect!</a>

"

--------------------------------------------------------------------------------------
第十一章 线程 纤维 (threads fibers)
fiber是ruby1.9支持的线程控制,方便了使用线程，不再需要像过去般继承各种类

::fiber常用于从一些有序序列里产生值给程序使用,Fiber对象处处可用，并且block里面的变量都可以保存，在new时的block里yield出来的参数就是使用这个fiber对象时的值，使用时用fiber对象.resume
例子：产生10个能被2除尽不能被3除尽的数
twos = Fiber.new do
  num = 2
  loop do
    Fiber.yield(num) unless num % 3 == 0
    num += 2
  end
end
10.times { print twos.resume, " " }
produces:
2 4 8 10 14 16 20 22 26 28

::thread，ruby1.9开始使用系统来产生线程，但ruby的thread大部分都是unsafe的，所以ruby使用了“可以产生多线程，单同一时间只执行一个线程”的方式。。。
一个线程会共享拥有所有全局变量，对象变量
例子，创建三个线程去获取信息
require 'net/http'
pages = %w( www.rubycentral.org slashdot.org www.google.com )
threads = []
for page_to_fetch in pages
  threads << Thread.new(page_to_fetch) do |url| #创建线程对象，放进thread数组，放进去的page_to_fetch变量会yield回到后面block中的url
    http = Net::HTTP.new(url, 80)
    print "Fetching: #{url}\n"
    resp = http.get('/')
    print "Got #{url}: #{resp.message}\n"
  end
end
threads.each {|thr| thr.join } #这一行保证了是三个线程运行完毕后，主线程才关闭 
produces:
Fetching: www.rubycentral.org
Fetching: slashdot.org
Fetching: www.google.com
Got www.google.com: OK
Got slashdot.org: OK
Got www.rubycentral.org: OK

：：Thread一些静态方法,Thread.current获取当前线程;Thread.list获取程序中的线程列表 Thread.status Thread.alive Thread.priority优先级

：：不同的Thread（包括主线程）也共享同一个变量的例子,thread可以在Thread.current[xxx]里面保存一些变量，外面直接用thread对象[]访问即可
count = 0
threads = []
10.times do |i|
  threads[i] = Thread.new do
    sleep(rand(0.1))
    Thread.current[:mycount] = count
    count += 1
  end
end
threads.each {|t| t.join; print t[:mycount], ", " }
puts "count = #{count}"
produces:
7, 0, 8, 6, 5, 4, 1, 9, 3, 2, count = 10

::Thread的exception与abort_on_exception 和$DEBUG设置有关，thread中raise的exception会在thread join的时候被捕获

Ruby的线程是 Native 线程，线程的调度是 OS 来实现的。但是呢，由于 GIL 的存在，同一时间只有获取了这个锁的线程在跑， 也限制了有GIL的语言利用多核的能力。

有 GIL 的限制并不代表你不能进行一些异步（通常意义上的异步）的操作。因为 GIL 不会被某个线程一直持有，所以其他的线程都有运行的机会。只是利用不上多核的能力 。就像以前，我们用单核 CPU 跑多线程程序类似。

再往下说，就和其他多线程编程一样了，Java 虽然没有GIL，但是如果写的程序中， 几个Java线程都对某个公共资源进行访问和修改，如果加锁进行保护，那么这几个线程也不能真正达到多核的利用。
--------------------------------------------------------------------------------------
第十二章 单元测试 (unit testing)
1.8用的是 Nathaniel Talbott’s Test::Unit framework 
1.9用的是 Ryan Davis’ MiniTest  MiniTest::Unit
用,Test::Unit例子
require_relative 'romanbug'
require 'test/unit'
class TestRoman < Test::Unit::TestCase
  def test_simple
    assert_equal("i", Roman.new(1).to_s)
    assert_equal("ix", Roman.new(9).to_s)
  end
end

：：assert_raises(RuntimeError) { Roman.new(5000) }  #断言exception

ruby -r debug debug-options programfile program-arguments

--------------------------------------------------------------------------------------
第十三章 Ruby Seting
::解决了gem安装慢的问题（或根本安装不了）
先上github下载gem-fast
然后进入解压gem-fast的目录运行 gem install gem-fast.gemspec
装好后在gem源中加入 http://gems.github.com/ (gem sources -a http://gems.github.com)
然后飞速下载使用gem吧！
中途遇到zlib::gzib问题，进gems/ruby版本目录/cache目录下把spece.xxx, lastxxx两个包给删了在更新下就可以
::gem安装包
$ gem query --details --remote --name-matches build #查找操作 details显示详细，remote表示远程库下载 name-mathces表示找有没符合正则"build"的包
$ gem list --details --remote --all builder #列出操作，列出显示所有有builder的包
$ gem install builder #安装builder 包
$ gem environment gemdir #查看配置文件夹
$ gem server #可以开启gem服务器，端口8808，可以方便查看文档
$ gem update --system
$ gem install builder --version '< 1' #指定安装version
$ gem build anagram.gemspec #从文件建立gem

#gem install from github

#删除原有gem source gem source -r http://rubygems.org/ gem source -r http://production.s3.rubygems.org/   #增加新source源 gem source -a http://gems.rubyonrails.org
::使用gem,假设已经下了builder,直接在程序中 require 'builder'就好

::encoding问题，假设一个文件原来是iso-8859-1,而我们操作系统是utf-8，我们可以在他打开的时候置顶两个编码让系统适应
f = File.open("iso-8859-1.txt", "r:iso-8859-1:utf-8")
puts f.external_encoding.name
line = f.gets
puts line.encoding
puts line
produces:
ISO-8859-1
UTF-8
olé

##补充编码
RGSS 默认是 UTF-8，你可以通过修改 $-K 或者 $KCODE 的值改变编码，以下几种是 Ruby 支持的编码：
# - None (n or N)
# # - EUC (e or E)
# # - Shift_JIS (s or S)
# # - UTF-8 (u or U)
# 那么 $KCODE = "S" 就告诉解释器现在开始使用 Shift_JIS 字符集了。注意这个修改不但改变了字符串和正则表达式的解码，同时也会改变整个脚本的解码方式，即解释器解码并解析脚本源文件的方法

::另外一个更好用的转码类 Iconv 已经deprecate
cd = Iconv.new("gbk","utf-8")
cd.iconv(str)

::方法3
html = open(url).read
html.force_encoding("gbk")
html.encode!("utf-8")
doc = Nokogiri::HTML.parse html
doc.css("body")

::编写，rdoc,在方法或类上面使用 =begin rdoc  =end
例：
=begin rdoc
this method xxxx
=end
def fuck
  #code...
end

#国内镜像#
$ gem sources -a http://ruby.taobao.org/
$ gem install foo
清华镜像
http://mirrors.tuna.tsinghua.edu.cn/rubygems/
--------------------------------------------------------------------------------------
第十四章 反射 元编程
先理顺祖先链:

BasicObject
    |
Kernel
    |
Object
    |
Class

假设有一个自己创建的MyClass:
MyClass.class => Class
MyClass.superclass => Object 
Class.class => Class 
Object.class => Class 
Object.superclass => BasicObject 
Kernel.class => Module 
Class.superclass => Module 
Module.class => Class 
Module.superclass => Object

方法会先从祖先链由下到上查找，查到了就执行

#!!!!!! ancestors()#
MyClass.ancestors #此方法可以检查出祖先链由下到上的顺序
 
(1)判断对象是否某个类或子类的各种方法
o.instance_of? c #判断o.class==c
o.is_a? c  #判断o是否c的子类,如果c是模块，则判断o.class有没include c
o.kind_of? c #同上

（2）eval方法（同js），强大的动态执行方法，可做外壳，扩展等
eval 'p "日你妈"' 

::可以在eval方法第二个参数设定binding变量，指定eval代码的上下文，如：
eval('@t',t.binding) #执行的是t这个对象里面的@t变量

::还可以直接使用instance_eval或者class_eval去指定具体调用哪个上下文的变量
t.instance_eval('t')
String.class_eval('def len; size; end')

::一些返回变量名称的方法！
global_variables #返回全局变量
local_variables #返回本地变量
Point::ORIGIN.instance_variables #Point这个类的对象变量 @x
Point.class_variables #Point这个类的类变量 @@y
Point.constants #Point这个类的静态常数 VERSION

::设置或者获取对象，类的各种变量
o.instance_variable_set(:@x,0) #设定o对象的变量为0
o.instance_variable_get(:@x)
Object.class_variable_set(:@@y,1)
Object.class_variable_get(:@@y)
Math.const_set或get  #类变量的举例

::获取对象的方法名
o.methods
o.public_methods(<false>) #如果加false则不从父类找
o.protect_methods
o.private_methods
o.singleton_methods

::获取Method对象
"s".method(:reverse)
String.instance_method(:reverse)

#!!!! 元编程重要的三个方法！ send, define_method, method_missing
::调用方法，使用send
例如直到"s"对象有个reverse的方法后，可以：
"s".send :reverse #调用
"s".send(:reverse,*args) #send第一个参数是方法名，后面则是调用这个方法的参数

::define_method在类中动态创建方法
Moduel.define_method(),他会自己动态创建一个实例方法

class MyClass
    define_method :new_method do |args1|
    	p "this is defined by #define_method and the args is #{args1}"
    end
end

m = MyClass.new
m.new_method(123)

::method_missing()方法
Kernel#method_missing, 当实例调用了没有声明的方法时，就会激活这个方法

class Lawyer
    def method_missing(method, *args)
        p "you called: #{method}(#{args.join(', ')})"	
	p "(you also gave me a block)" if block_given?
    end
end

l = Lawyer.new
l.fuck
#要注意respond_to?方法不能识别method_missing所创建的方法,因此每当使用method_missing的时候都要重写repond_to?方法
#!!注意有时想在method_missing定义新方法的时候，要注意有可能和类本来继承而来的方法重名， 这样想使用method_missing方法就失效了,解决方法是先在代理类删除集成而来的方法(白板类), 
#Module#undef_method  删除所有方法
#Module#remove_method 只会删除接收者的方法

还有const_missing()方法
当引用一个不存在的常量的时候，这个常量会作为符号传给const_missing方法

#!!!!!########################################
::序列化对象
例如有个对象c
写到文件：
File.open("object","w+") {|f|
  Marsha1.dump(c,f)
}

读取回来
File.open("object","r") {|f|
 o= Marsha1.load(f)
}
-----------------------------------------------------------------------
ruby实现的动态代理 delegate
require 'delegate'
class Assistant
    def initalize(name)
	@name = name
    end

    def read_email
	"#{@name} is reading email for manager"
    end
end

class Manager < DelegateClass(Assistant)
    def initialize(assistant)
	super(assistant)
    end

    def meeting
	"go to metting"
    end
end

eric = Assistant.new('eric')
jas = Manager.new(eric)
jas.metting #=> "go to metting"
jas.read_email #=> "eric is reading email for manager"

原理是Manager创建时会把method_missing的方法交给代理的Assistant
-----------------------------------------------------------------------
作用域,作用域门,scope研究 
#ruby有三作用域门,class,module,def,在这些关键字出现的时候会创建一个域，这扇门不会给之前的变量通过,怎样实现通过呢?看下面例子:
var a = 'xxx'
class Xo
    '这里怎样才能获取a呢'
end
#要知道block可以获取同域的变量，成为一个闭包,以前我们可以用Class.new去创建一个类，这个方法接收一个block,举一反三地,define_method, Module.new 也可以通过block获取

Xo = Class.new do
    p a
    define_method :my_method do
	p a
    end
end

#如此通过block可以从一个作用域看到另外一个作用域的变量，实现了用方法去代替门, 可以称之为扁平作用域(flattening the scope/Flat Scope)

#!!有了扁平作用域就可以随便折腾各种作用域,例如:
def aa
    b = 0
    Kernel.send :define_method, :counter do
	p b
    end
end

counter #=>b 这样可以随处都获取a方法里面的一个变量
-----------------------------------------------------------------------
instance_eval 的一些little trick
class A
    def initialize()
	@v = 1 
    end
end
a = A.new
a.instance_eval do
    self #=> a
    @v #=>1
end
instance_eval后面跟的block作用域里头的self就是调用instance_eval的对象，这个self十分强大，甚至可以访问私有方法和实例变量

#ruby 1.9 新增一个instance_exec,除了有instance_eval的作用之外，还增加传入参数
A.new.instance_exec(10) {|temp| @v + temp} #=>11

由于这东西功能太强大恐怖，所以多用于irb打开对象，真实环境需要慎用
-----------------------------------------------------------------------
当前类
在定义class的时候，方法外的self就是当前类
class MyClass
    self #这个代表当前类MyClass
    def my_method
	#因此这是MyClass的一个实例方法
    end
end

#!! class_eval
class_eval可以给指定上下文的类执行一个块
通过下面的方法使用class_eval给一个类动态添加方法呢
def add_method(a_class)
    a_class.class_eval do
	def m;"Hello";end
    end
end

add_method(String)
"abc".m #=> "Hello" 

#类实例变量, 注意和实例变量（对象变量区分）
class C
    @var = 1 #在类中方法外定义的实例变量是类实例变量（类似静态变量，实质是类C对象的实例变量）
    def self.read
	@var
    end

    def write(var)
	@var = var
    end
end

cc = C.new
cc.write 2
cc.read #=>2 对象修改的是自己的@var
C.read #=>1 类的@var不会改变

#还有一种是类变量@@var，这种可以给类和实例共用,但这东西不好之处在于其实他是属于main的，也就是属于Object的，所以可以给其他类改写，所以一般都不会使用
#########################
--------------------------------------------
单件方法 #只给单个对象添加的方法
首先是使用def给某个对象实例添加方法
str = "123"
def str.title?
    self.upcase == self
end
str.title? #=> true 
str.singleton_methods #=>[title?] 

!!如果结合之前的概念去理解,定义类的时候，其实类只是对象，类名是常量, 所以定义类方法就是定义类的单件方法
class C;end
def C.some_method
    #和上面定义str的单间方法相似吧，只有C这个class上才能跑的方法
end

--------------------------------------------
类宏 #可以使用在类定义中的方法都叫类宏,例如 attr_XXX
attr_accessor这种定义在Module中的方法，可以到处使用
attr_accessor :fucker 看上去好像关键字，其实只是执行了一个方法

--------------------------------------------
Eigenclass eigenclass 单件类!!!!!!!!!!!!!!!
问题:
如上面的str.title?定义好的单件方法，这个方法究竟存在于哪里呢?
首先不可能存在于str对象里，因为它不是一个类,其次也不可能存在于String中，不然每个String的实例都会有这个方法
其实单件方法存在于ruby的Eigenclass里面

Eigenclass是ruby每一个对象的特有隐藏类,ruby的对象在查找方法时，第一个先会查找eigenclass
有总特殊的关键字可以让你进入某个对象的eigenclass
class << an_obj
    #写入到eigenclass的代码
end

如果想获得eigenclass的引用，只要在这种特殊书写方式中最后返回个self就行
obj = Object.new
eigenclass = class << obj
    self
end
eigenclass.class #=> class 

#eigenclass特点:只有一个实例，不能被继承，是对象的单件方法存放的地方

所以有种技巧只给类添加属性
class C
    class << self
	attr_accessor :c
    end
end
C.c = 'fuck'

!!用module给class定义类方法
module Jas
    def self.cry;'jas';end
end

class Xo
    include Jas
end
Xo.cry #=> no_method error, 出错的原因是,类include module的时候，他只能获取module的实例方法，不能获取module的类方法
#!!我们可以通过这个class的单件类来帮忙,在module里定义的是实例方法，然后在class中的eigenclass中导入

修改成:
module Jas
    def cry;'jas';end
end

class Xo
    class << self
        include Jas
    end
end
Xo.cry #=> jas 
#上面这种技术叫类扩展 !!########### 
#在引申出去的话，可以成为对象扩展
obj = "fuck"
class << obj
    include Jas
end
obj.cry #=> jas 

##!!如果觉得这样定义单件类比较麻烦，可以使用Object#extend方法，这是一个ruby让你定义eigenclass的快捷方式
obj.extend Jas
class SomeClass
    extend Jas
end

总结：
1.类中包含模块，模块的方法会变成类的实例方法
2.在类的eigenclass包含模块，模块的方法会变成类方法
3.在任意对象的eigenclass中包含模块，模块的方法会变成这个对象的单件方法
--------------------------------------------
方法别名， 环绕别名
alias :new_method :old_method #注意alias是一个关键字而不是一个方法，所以两个符号之间没有逗号

环绕别名, #先定义别名,再重新定义方法,别名可以把原方法绑定下来，然后使用原方法名定义的新方法可以对原方法做处理，看下面例子
String.class_eval do
    alias :real_length :length
    def length
	real_length > 5 ? "long" : "short"
    end
end
"fuck that shit".length #=> long
"fuck that shit".real_length #=> 5
步骤:
1 给方法定义一个别名
2 重新定义这个方法
3 在新方法中调用老方法（使用别名）

注意:
环绕别名是一种猴子补丁
环绕别名不要加载两次，不然会另程序崩溃?

--------------------------------------------
关于几个eval的binding对象
几个eval方法的第二个参数都可以传入一个Binding对象,用以指定上下文
Kernel#binding
class MyClass
    def my_method
	@x = 1
	binding
    end
end
b = MyClass.new.my_method
eval "@x", b

还可以使用Ruby顶级作用域的常量,TOPLEVEL_BINDING

可以把Binding对象看成是一个比块更纯的闭包，因为他只包含作用域，不带代码
--------------------------------------------
嵌套irb，可以在irb中指定上下文
s = "abc"
irb s #指定irb上下文
reverse #=>"cba" 
exit #back_to irc0

--------------------------------------------
hook 钩子方法
ruby里面钩子方法的作用是，当类被继承，module被包含的时候会触发这些钩子方法，我们可以改写这些钩子方法，让程序更灵活的基于某些事件去执行代码
例如inherited方法就是当类被集成的时候就执行这个方法，默认为空，可以重写
class String
    def self.inherited(subclass)
	puts "#{self} was inherited by #{subclass}"
    end
end
class MyString < String;end 

还有各种钩子方法:
Module#included(receiver) #参数是要mixin这个module的类或模块
Module#extend_object() #可以在模块扩展类时执行代码
Module#method_added, method_removed(), method_undefined(), 方法相关事件的代码,参数是method的引用

除了使用self.included的方法外，还可以自己重写本来的include(注意这里是include不是included)来实现钩子
class JAS
    def self.include(*args)
	puts "fuck that shit"
	super #这样既有了钩子代码，include的时候也能扔给super去mixin模块
    end

    include XO
end
--------------------------------------------

补充
一. Time和Date
（1）Time 使用C语言的原生时间戳
t = Time.new (或Time.now)
p t #打印现在时间
一些方法获取各种时间参数
t.year t.month t.day t.hour t.min t.sec t.wday t.mday t.yday t.zone
获取timestamp
t.to_i #从1970年算起的秒数

::指定的方式建立Time对象
t = Time.mktime(2006,5,15,05,03,30)

::Time计算
可以直接两个Time对象+-返回float 秒数

::时间输出格式化
t = Time.new
p t.strftime("%Y/%m/%d %H:%M:%S")

::解析字符串（字符串转回Time对象）
Time.parse("Sat Apr 15 11:50:30 +8000 2006")

::timestamp转换成时间格式
Time.at(timestamp)

二. $SAFE
0 默认,受污染也不检查
>=1 不允许潜在威胁
>=2 禁止从外部科协地方读入程序
>=3 所有新创建的对象都被认作受污染
>=4 所有对象都不能够修改

三. 猴子补丁
类在定义过后，可以再其他地方增添 取消类的方法，系统类也行
如 
class foo
  def p1
    #...
  end
end

然后在其他地方可以继续定义
class foo
  def p234
    #...
  end
end
这样的话，foo这个类相当于增加了方法，即使存在的对象也可以直接使用增添的方法。或在想增加String Array等系统类方法时也可以用这种方式

::在类内部的方法别名和取消已定义的方法
alias 别名 原名
undef 方法名
remove_method() #只取消本类的方法名，不取消父类


------------------------------------------------------
补一些技巧
#空指针保护
多用||= 这样可以杜绝返回nil

#方法参数的技巧，解决参数固定顺序的麻烦,实质是最后一个参数使用了hash，但调用时可以省略大括号
def my(args)
    p args
end

my(1, name:'jas',sex:'mail') #=> [1,{:name=>'jas',sex:'mail'}] ,使用时就不必再理会name和sex的顺序了

#长方法链时候使用tap检验中间可能出错的环节,如：
%w(a b c ).push('d').shift.upcase.next
假如shift可能会出错,可以中间插入tap方法检验
%w(a b c ).push('d').shift.tap{|x|puts s}.upcase.next
tab的原理,yield self给block做检验，最后还会返回self
def tap
    yield self
    self
end

yield self还能这么用，在initialize里面yield出来用以设定一些初始值
spec = Spec.new do|s|
    s.name = 'xxx'
    s.age = 'yyy'
end
####################

#Symbol#to_proc 这诡异的东西相当流行
我们对集合使用map的时候
[1,2,3].map{|x| x.fuck} 有时候会觉得这样经常用{}很麻烦

ruby1.9开始使用to_proc的写法
to_proc的代码:
class Symbol
    def to_proc()
	Proc.new {|x| x.send self}
    end
end
[1,2,3].map(&:fuck.to_proc)
简化后是
[1,2,3].map(&:fuck)

1.9的to_proc甚至支持多个参数
[1,2,5].inject(0){|memo,obj| memo+obj} #=>8 
#new
[1,2,5].inject(0,&:+) #=>8 ,so cool!
------------------------------------------------------
附录:


依赖包:sudo apt-get install build-essential bison openssl libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-0 libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev ncurses-dev

rvm: 
$ sudo apt-get install git-core
$ bash -s stable < <(curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer)

#修改~/.bashrc 文件，加入
# add rvm
if [[ -s "$HOME/.rvm/scripts/rvm" ]]  ; then 
    source "$HOME/.rvm/scripts/rvm" ;
fi
#rvm install ruby-1.8.7 --head --docs
#rvm remove xxxx
#rvm list # list known可以查看远程一共有哪些版本
#rvm use xxxx --default
#嫌慢可先把源码包复制到.rvm/archives下面再install

#在~/.gemrc 加入
gem: --no-ri --no-rdoc 会另geminsatal速度更快

#rvm其他应用
rvm list know #列出所有ruby已知版本
rvm use 1.9.3 --default #设置为系统默认ruby版本

#gemset 独立虚拟的gem环境，每一个gemset都是相互独立的,如果你在1.9.3建立了一个rails3的gemset, 切换到1.8.7那么rails3这个gemset也会不存在
rvm gemset create rails3 #创建gemset
rvm use 1.9.2@rails3 #切换到1.9.2和rails3的gemset
rvm gemset list #列出所有的gemset
rvm gemset emty 1.9.2@rails3 #清空这个gemset所有的gem
rvm gemset delete rails3 #删除一个gemset

#.rvmrc使用设置项目默认的ruby版本和gemset
例如有一个rails项目，在这个项目下面创建一个.rvmrc的文件，然后加入：
rvm use 1.9.3@rails2 
然后不管你当前ruby版本是什么这个目录下的项目运行都会使用文件内设置的版本和gemset

#有时候gem install rails 之后系统提示找不到rails的话，创建一个软链接就好了
ln -s /home/jas/.rvm/gems/ruby-1.9.3-p125/gems/railties-3.2.2/bin/rails /usr/local/bin/rails

升级rvm
rvm get stable
rvm get head
或者这样升级
$ curl -L https://get.rvm.io | bash -s stable # update to stable
$ curl -L https://get.rvm.io | bash -s head   # update to head
$ rvm reload

rvm requirements 查看安装ruby尚欠什么包

#到ruby toolbox看那些gem排名够高
www.ruby-toolbox.com

#rvm 修改安装源为taobao
sed -i -e 's/ftp\.ruby-lang\.org\/pub\/ruby/ruby\.taobao\.org\/mirrors\/ruby/g' ~/.rvm/config/db
or
sed -i 's!ftp.ruby-lang.org/pub/ruby!ruby.taobao.org/mirrors/ruby!' $rvm_path/config/db

#帮rvm版本ruby安装falcon版ruby
rvm get head
rvm reinstall 1.9.3 --patch falcon
rvm use ruby-1.9.3-p327-falcon --default

或重新安装
rvm install ruby-1.9.3-p286 --patch falcon -n falcon

ruby2.0
rvm get latest
rvm install 2.0.0
rvm use 2.0.0 --default

#ubuntu error
RVM is not a function, selecting rubies with 'rvm use ...' will not work.
go to the terminal setting -> title and command -> run command as alogin shell


rvm pkg install openssl
rvm install 2.0.0 --with-openssl-dir=~/.rvm/usr or
--with-openssl-dir=brew --prefix openssl --with-readline-dir=brew --prefix readline


::2.1.1 marverick ssl坑
rvm osx-ssl-certs update all
rvm reinstall ruby-2.1.1

最后解决方法
rvm reinstall ruby-2.1.1 --trace
看到报错前有这个地址https://rubygems.org/api/v1/versions/rubygems-update.json
用safari打开，提示证书有问题，设成总是信任
------------------------------------
编程习惯
把数据插入到string变量的时候，不要使用+，用<<追加,例如:
html=''
html << Some String from web
追加
-----------------------------------
Ruby 自己的 ri 太慢，装个 fastri 就爽多了。 
gem install fastri
以后就可以用qri

----------------------------------
Ruby benchmark ruby提供的benchmark测试程序性能

require 'benchmark'
    Benchmark.bm do |b|
    	b.report "descript" do    		
	    10000.times do xxxx
    	end
    end



-----------------------------------
使用ruby链接Mysql
gem install mysql2
require 'mysql2'
c = Mysql2::Client.new(username:'ff', password:'ff',localhost:'xx',database:'sss')
r = c.query('select * from fucking')
r.each {|row| do sth}
#可以设置r.each(:symbolize_keys => true, :as => :array ) {do xxx}

#一些预定义的方法
Mysql2::Client.default_query_options
which defaults to:
{:async => false, :as => :hash, :symbolize_keys => false}
that can be used as so:
# these are the defaults all Mysql2::Client instances inherit
Mysql2::Client.default_query_options.merge!(:as => :array)
or
# this will change the defaults for all future results returned by the #query method _for this connection only_
c = Mysql2::Client.new
c.query_options.merge!(:symbolize_keys => true)
or
c = Mysql2::Client.new
c.query(sql, :symbolize_keys => true)

------------------------------------
##!! 委托模式
extend Forwardable
def_delegator 委托对象，委托方法1, 委托方法2

class A
    extend Forwardable
    def_delegator @yy, :fuck
    def initialize(yy)
	@yy = yy
    end
end

A.new(yy).fuck() #会调用@yy的fuck方法


---------------------------------
针对当时常量不能在method里面动态赋值，可以先用扁平作用域先把要赋值的东西交给和常量同一作用域的一个变量，然后在这个地方赋值给常量
c = Module.new(something) do
    blahblabhla
end

Config = c
---------------------------------
__FILE__ 当前路径
获得当前执行文件的文件名：

__FILE__

获得当前文件的目录

File.dirname(__FILE__)

获得当前执行文件的完整路径

require ‘pathname’
Pathname.new(__FILE__).realpath

获得当前执行文件的目录完整路径

require ‘pathname’
Pathname.new(File.dirname(__FILE__)).realpath

如果使用$0: $0是整个ruby执行文件最顶层文件的路径。因此使用if __FILE__==$0可以判断当前ruby文件是被引用还是被执行。

File.basename(filename[, suffix]):返回filename中的最后一条斜线后面的部分。若给出了参数suffix且它和filename的尾部一致时，该方法会将其删除并返回结果。
File.dirname(filename) :以字符串的形式返回filename中最后一条斜线之前的部分。若文件名中不含斜线，则返回"."(当前目录)。
File.expand_path(path[, default_dir]) 将path展开为绝对路径后返回该路径字符串。若path是相对路径则以default_dir为基准进行扩展。若没有default_dir或其值为nil时将使用当前目录。开头的~会被扩展为主目录(使用环境变量HOME)，而~USER会被扩展为相应用户的主目录。
------------------------------
针对openssl 用rvm重新安装openssl
rvm pkg install openssl
rvm reinstall 1.9.3-p194 --with-openssl-dir=~/.rvm/usr


--------------------------
打开gem的几种方法
首先在.bashrc
export EDIT="vim"
一个是进入rails目录 bundle open
对于gem install 的,可以装些gem方便我们去做
1)gem install open_gem
gem open rails

2)gem install qwandry
qw rails

-------------------------
CharlockHolmes 检测编码的gem
gem install charlock_holmes
if you cant find your icupath, do this:
gem install charlock_holmes -- --with-icu-dir=/path/to/installed/icu4c

Usage:
require 'charlock_holmes'
contents = File.read('test.xml')
detection = CharlockHolmes::EncodingDetector.detect(contents)


------------------
pry 
ls anything 查看这个对象里的一切方法，父类方法,变量等等
binding.pry 代码里写这个就进入pry的debugger，可以step continute next 之类
edit-method 神奇东东，直接打开这个方法的源代码



------------------
Ruby2.0 新特性
1)Refinements
在module命名空间里面使用这东西，那么之下定义的方法只有在命名空间内才有效，在命名空间之外会失败
module NumberQuery
  refine String do #关键字refine
    def number?
      match(/^[1-9][0-9]+$/) ? true : false
    end
  end
end

begin
  "123".number?
rescue => e
  p e   #=> #<NoMethodError: undefined method `number?' for "123":String>
end

在module命名空间内则随便用，好处是不会污染到外面已存在的对象
module NumberQuery
  p "123".number?   #=> true
end

想在其他已存在的module命名空间里面用到的话，可以用 using 关键字 
module MyApp
  using NumberQuery#个人觉得 using这名取得一般...

  p "123".number?   #=> true
  p "foo".number?   #=> false
end

2)Keyword Arguments
def wrap(string, before: "<", after: ">")
  "#{before}#{string}#{after}" # no need to retrieve options from a hash
end

# optional
p wrap("foo")                                  #=> "<foo>"
# one or the other,可以只设其中一个值
p wrap("foo", before: "#<")                    #=> "#<foo>"
p wrap("foo", after: "]")                      #=> "<foo]"
# order not important, 顺序可以随便放
p wrap("foo", after: "]", before: "[")         #=> "[foo]"

# double splat to capture all keyword arguments, or use as hash as keyword, 两个星号表示可以把整个keyword arguments抓下来
# arguments
def capture(**opts)
  opts
end
p capture(foo: "bar")                          #=> {:foo=>"bar"} 返回的是hash

# keys must be symbols 传进的key一定要是hash 
opts = {:before => "(", :after => ")"}
p wrap("foo", **opts)         #=> "(foo)"  注意这里的**opts, 代表把上面的opts当做keyword arguments

#旧的hash传参数方法继续支持，其实用起来不会有太大的不同
p wrap("foo", :before => "{", :after => "}")   #=> "{foo}"

3)Enumerator lazy
可以遍历无限大集合的新方式
require "timeout"
begin
  timeout(1) {[1,2,3].cycle.map {|x| x * 10}} #cycle()函数里面不指定次数的话就是无限次完全遍历当前集合,指定次数就是遍历多少次
rescue => e
  p e   #=> #<Timeout::Error: execution expired>
end

p [1,2,3].lazy.cycle.map {|x| x * 10}.take(5).to_a   #=> [10, 20, 30, 10, 20] 本应不断循环，但是用了lazy
#A lazy enumerable will evaluate the entire chain for each element at a time, rather than all elements at each stage of the chain, so the following will output at 1 second intervals. Without #lazy all output would come after 3 seconds

4)Enumerator prepend
module A
  def foo
    "A"
  end
end

class B
  include A

  def foo
    "B"
  end
end

p B.new.foo   #=> "B"
#以前在class里面写的同名方法会覆盖掉module里面的方法,可以用回super去调用复写了的module方法
#现在用prepend的话

class C
  prepend A

  def foo
    "B"
  end
end

p C.new.foo   #=> "A" 这种情况还是可以用super访问到class里面定义的foo方法，ruby就是要提供更多选择给我们...

5)新的to_hash方法to_h
p({:foo => 1}.to_h)   #=> {:foo=>1}
Baz = Struct.new(:foo)
baz = Baz.new(1)
p baz.to_h            #=> {:foo=>1}

所以以前的写法
def foo(opts)
  raise ArgumentError, "opts must be a Hash" unless opts.is_a?(Hash)
  # do stuff with opts
end
可以变成这样：
def foo(options)
  if options.respond_to?(:to_h)
    opts = options.to_h
  else
    raise TypeError, "can't convert #{options.inspect} into Hash"
  end
  # do stuff with opts
end

6)symbol array的方便写法%i()
p %i{hurray huzzah whoop}   #=> [:hurray, :huzzah, :whoop]

7)正则表达式的引擎转成Onigmo
(?(cond)yes|no) #有点像三目运算符，如果cond先match的话，就再去match yes,否则就去match no

例子
regexp = /^([A-Z])?[a-z]+(?(1)[A-Z]|[a-z])$/
#开头大小写字母都可以,中间要都是小写字母, 然后引用回括号1,前面的大写match到吗？match到再看看是否A-Z结尾，否则是a-z结尾
#这例子只会检测到前后都是大写或都是小写 并且中间要是小写　的例子
regexp =~ "foo"   #=> 0  
regexp =~ "foO"   #=> nil
regexp =~ "FoO"   #=> 0

-----内存泄露
1 GC.stat
2 puts "vmmap #{Process.id}" #linux 用pmap
3 
counts = Hash.new{ 0  }
ObjectSpace.each_object do |o|
    counts[o.class] += 1
end
然后把counts 打到文件 diff一下
=======

%Q %q %W %w %x %r %i
%Q
用于替代双引号的字符串. 当你需要在字符串里放入很多引号时候, 可以直接用下面方法而不需要在引号前逐个添加反斜杠 (\")

>> %Q(Joe said: "Frank said: "#{what_frank_said}"")
=> "Joe said: "Frank said: "Hello!"""
(...)也可用其他非数字字母的符号或成对的符号代替, 诸如[...], !...!, +...+,{...}, <...>等.

以下写法全部与上面等效:

>> %Q!Joe said: "Frank said: "#{what_frank_said}""!
>> %Q[Joe said: "Frank said: "#{what_frank_said}""]
>> %Q+Joe said: "Frank said: "#{what_frank_said}""+
除此之外还可省略Q写作:

>> %/Joe said: "Frank said: "#{what_frank_said}""/
=> "Joe said: "Frank said: "Hello!""" 
%q
与%Q类似, 但是表示的是单引号字符串

>> %q(Joe said: 'Frank said: '#{what_frank_said} ' ')
=> "Joe said: 'Frank said: '\#{what_frank_said} ' '"    
%W
语法近似于%Q, 用于表示其中元素被双引号括起的数组.

>> %W(#{foo} Bar Bar\ with\ space)
=> ["Foo", "Bar", "Bar with space"] 
%w
用于表示其中元素被单引号括起的数组. 比较奇怪的是\(斜杠空格)会被转化成(空格), 但是其他的内容不会.

>> %w(a b c\ d \#e #{1}f)
=> ["a", "b", "c d", "\\#e", "\#{1}f"]
%x
使用`方法执行一段shell脚本并返回标准输出内容.

>> %x(echo foo:#{foo})
=> "foo:Foo\n"    
%r
语法近似于%Q, 用于正则表达式.

>> %r(/home/#{foo})
 => "/\\/home\\/Foo/"     
%s
用于表示symbol, 但是不会对其中表达式等内容进行转化

>> %s(foo)
=> :foo
>> %s(foo bar)
=> :"foo bar"
>> %s(#{foo} bar)
=> :"\#{foo} bar"
%i
Ruby 2.0 之后引入的语法, 用于生成一个symbol数组
2.0.0p247 :014 > %i(a b c)
=> [:a, :b, :c] 
"
