JAVA
设计原则:找出应用中可能需要变化之处,把它们独立出来,不要和那些不需要变化的代码混在一起。把会变化的部分取出并封装起来,以便以后可以轻易地改动或扩充此部分,而不影响不需要变化的其他部分.
::封装变化

::针对接口编程,而不是针对实现编程。

::开放关闭原则：类应该对扩展开放，对修改关闭 （装饰）

::依赖倒置原则：要依赖抽象，不要依赖实体类(工厂)
摆脱依赖做到三点 (1)变量不可以持有具体类的引用(2)不要让类派生自具体类，最好是派生自一个抽象接口（3）不要覆盖基类中已实现的方法，基类存在的方法应该被众多子类共享，而不是重写

::最少知识原则:只留下密友(减少对象之间的交互，例如类里面除了调用自身，作为参数传进来的对象，和接口类外尽量不要再调用其他类)，缺点：增加了复杂性和牺牲了性能

::河里活原则:别调用我们，我们会调用你(模板，父类设个hook(),子类重写了后，父类可以在模板方法里决定什么时候调用)

-------------------------------------------------
一.策略模式
定义算法族，分别封装，让他们可以互相替换，独立于使用他们的客户（主要就是继承接口+多态的应用）

::把需要的功能设计成接口，然后在父类持有接口的引用，子类需要哪个接口就使用哪个接口的实现类，甚至可以定义set 接口方法，在运行时动态改变子类的行为

-------------------------------------------------
二.观察者(observer)模式
::在对象之间定义一对多的依赖，这样一个更新，N个更新
::类似报纸订阅服务，报社每天有新报纸都会送报纸给你，你可以每天从报社接收新信息，当你不想订阅了就可以退订，你就是一个观察者
::设计要点，被观察者（p），观察者（o） (jdk内部实现了这种模式,java.util的Observer接口与Observable类,尽量自己实现，不用JDK的)
推的方法：P里面设计维护一个o的数组，当p发生更改，用一个方法通知里面的所有o，也有添加和删除o的方法，这种是P主动推给O的方法
例子:每次天文台更新天气参数，你的公告版上天气的参数跟着改
-------------------------------------------------
三.装饰者模式（jdk里面的IO类都用这种模式）
::允许类容易扩展,在不修改现有代码的情况下,就可搭配新的行为

装饰者和被装饰对象有相同的超类型。
你可以用一个或多个装饰者包装一个对象。
既然装饰者和被装饰对象有相同的超类型,所以在任何需要原始对象(被包装的)的场合,可以用装饰过的对象代替它。!

::设计要点：装饰者和被装饰者都有继承同一个父类，并且里面持有一个父类的引用，每次构造的时候就把要装饰的类传进来给这个父类引用，然后再在父类的方法基础上不断叠加
例子:在星巴克里面，每杯饮料类和总价类都有继承了一个父类（有价钱和描述），调味料又继承了总价类，然后总价接口有父类的引用，每次选好饮料后，选调味料时，就把饮料传进总价对象，然后每次添加调味料时就把总价对象不断传进调味料中（因为里面都持有一个相同的父类应用），然后总价对象的 价钱就是就是总价了

::优点：装饰者与被装饰者实质是持有同样的父类引用，他们可以互相在前面/后面加入自己的行为，一层包一层地组合出一个组建
::缺点：会出现很多小对象，造成程序复杂化
-------------------------------------------------
四.工厂方法(模式)
用于生成对象，通常是 给我一个指定类型，然后我创建一个该类型的Product对象出来
abstract Product factoryMethod(String type)
::定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类
::工厂方法是创建一个抽象方法，他的实现就是实现了这个方法的 简单工厂
::例子：生产pizza，PizzaStore有子类纽约店和芝加哥店，然后都同时生产一个接口pizza，然后根据具体哪个店生产哪种pizza，典型的多态应用

抽象工厂
提供一个接口，创建相关或依赖对象的家族，而不用指明具体类，客户用接口创建产品时，不需要关心具体产出的产品是什么
例子：pizza店生佐料的例子，根据不同的店会生产不同的原料口味

::工厂方法和抽象工厂区别：工厂方法是使用继承，子类去改写父类的抽象方法来产生对象。抽象工厂是使用接口，并且通过组合的形式来产生对象的一个大家族，但是在扩展的时候，每次新加接口，子类都要改一下。

::适用环境:当创建产品家族或者想让相关产品集合起来，就用抽象方法。

::两种工厂都是为了产生对象，并且都是把对象的产生延迟到子类里面生产，都是为了减少客户端依赖，促进松耦合
-------------------------------------------------.
五.单件模式(单例？singleton?)
确保类只有一个实例，并提供一个全局访问点
public class Singleton{
    private static Singleton s;//保证静态，只产生一个对象变量
    private Singleton(){} //把构造器私有化，只有类内部才能new
    public static Singleton getInstance(){//静态方法保证只能产生一个对象，多线程时把这个方法改成同步synchronized
	return s=(s==null)?new Singleton():s;//判断对象是否存在，不存在就new，存在则返回这个引用
    }
}
另外还有双重检查枷锁的情况，即是第一次使用getInstance会同步，然后之后对象已经存在的话，就不再同步；注意有可能会有两个以上类加载器，那样就会产生多个对象，最好手动置顶类加载器
-------------------------------------------------
六.命令模式 封装调用
将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。
::发出请求的对象(遥控)和执行请求的对象姐藕（Light），两者之间通过命令对象（lightON/OFFCommand)去沟通，命令对象封装好执行者
::（万能遥控的例子，多个on/off控制不同对象，只要每个对象都实现一个on/off接口，使用时直接把on/off接口传给遥控器就行）
::适用环境:日程安排，队列，线程池,事务(例如每一个小流程都记录到磁盘，死机后再按日志恢复，事务继续)
-------------------------------------------------
七 适配器模式  外观模式
适配器 拖苏，例如把电源插头2插转3插，适配器就像中间人，把一种原来的接口转换成符合另一要求的接口
::简单来说，就是写一个chicken adapter继承duck的行为，然后再用chicken的方法重写duck的方法

::外观模式 把几个接口简化成一个

::适配器和外观模式的区别在于他们的意图，适配器是为了把接口转成客户想要的接口，外观模式在于简化
-------------------------------------------------
八.模板方法 模式
::在一个方法中定义一个算法骨架,而将一些步骤延迟到子类。使得子类可以在不甘变算法结构的情况下，重新定义算法的某些步骤
（冲茶和咖啡的例子，都有4个步骤，只有2个是互相不同，把四个步骤包装到父类，然后分开实现二个不同的方法就行，使用时直接用包装了四个步骤的方法）

::例如Comparable接口，事实父类已经定义了sort，只要子类重写了Comparable接口，就可以用sort
