# 编程珠玑

<!-- MarkdownTOC -->

- 第 1 章：开篇
    - 习题与个人解答
    - 深入阅读
- 第 2 章：啊哈！算法
    - 三个问题
    - 问题 1
    - 问题 2
    - 问题 3
    - 习题与个人解答
- 第 3 章：数据决定数据结构
    - 习题与个人解答
    - 深入阅读
- 第 4 章：编写正确的程序
    - 习题与个人解答

<!-- /MarkdownTOC -->


## 第 1 章：开篇

对小问题的资信分析有时可以得到明显的实际益处。

**正确的问题**。明确了问题，就更能找到最佳的解答。

**位图数据结构**。该数据结构描述了一个有限定义域内的稠密集合，其中的每一个元素最多出现一次并且没有任何其他数据与该元素相关联。即使这些条件没有完全满足(例如，存在重复元素或额外的数据)，也可以用有限定义域内的键作为一个表项更复杂的表格的索引。

**多趟算法**。多趟读入其输入数据，每次完成一步。

**时间-空间折中与双赢**。只有在原始的设计远非最佳方案时，才有可能时空双赢。

**简单的设计**。设计者确定其设计已经达到了完美的标准不是不能再增加任何东西，而是不能再减少任何东西。

### 习题与个人解答

> 1.如果不缺内存，如何使用一个具有库的语言来实现一种排序算法以表示和排序集合？

python 的 list 的 sort 方法就挺好，简单粗暴

    list = [1,2,3,4,5]
    list.sort()

> 2.如何使用位逻辑运算(与，或，移位)来实现位向量？

位向量的实现就是用比特位0,1来表示一些特定信息，通常是用数组，每个int中包含32个bits，当我们定位某个位置时，先确定索引是在哪个int中，然后再确定int中的那个位对应索引。

c++中有现成的 bitset，原理应该差不多

> 3.实现位图排序并度量运行时间

位图的实现我用了三种，一个是c语言的（简称cvec），一个是c++的（简称cppvec），还有时c++现成的bitset（简称bitset）。系统排序用的是sort命令，加上-n选项。排序用了c的qsort，c++的sort和c++的set。

    cvec  1.737 1.001
    cppvec 1.769 1.033
    bitset 2.644 1.908
    系统sort命令 5.290 4.554
    qsort 2.081 1.345
    sort 2.802 2.066
    set 5.921 5.185

输入输出的时间是0.736s。左右分别为带输入输出和不带的。

可以看出两种语言位图的实现都是效率最高的，c++中的bitset，set，sort虽然效率上差了点，但是实现上非常方便，而且能保证一定的正确性。系统的排序实在方便，一句命令就可以搞定(`sort -n < in -o out`).

> 4.如何生成小于 n 且没有重复的 k 个整数？

如果要想生成这样一个数组，可以直接从头到尾循环，每个数随机位置交换值就可以。

    #include<iostream>
    #include<cstdlib>
    #include<algorithm>
    #include<cstdio>
    using namespace std;
    const int N = 10000000;
    const int K = 10000000;
    int randint( int l, int r ){
        return rand() % ( r-l ) + l;
    }
    int a[ N ];
    int main(void){
        for( int i = 0; i < N; i++ )
            a[i] = i;
        for( int i = 0; i < K; i++ ){
            swap( a[i], a[ randint(i,N) ] );
            printf("%d\n",a[i]);
        }
        return 0;
    }

> 5.如果存储[0,10000000]大概需要1.25MB，但内存限定为1MB，要如何处理呢？

可以将输入文件分成两分，第一份保存[0,5000000)的数，第二个文件保存[5000000,10000000)的数字，然后分别进行排序，所用内存就可以降到1MB以内。如果我们把文件分成k份（每份都存一定区间的数），那么就可以在n的时间，n/k的空间内完成排序。

> 6.如果每个整数不只是出现一次而是最多可能出现十次，那么要如何修改算法呢？

每个整数最多出现10次，那么保存每个数字信息的空间不再是1bit了，可以用4bits来保存，可以类比第五题，可以分成4份，在n/4的空间内完成。同样，当保存数字信息的量变化时，分成更多份，就可以在更小的空间内完成。

> 7.程序还需要进行哪些错误检测，如何处理？

**数出现超过一次**。当第二次更新的时候，相应位已经是1了，这个时候提示错误。

**当输入小于0或者大于等于n**。当输入数字时候对其进行范围判断，忽略或者提示错误。

**不是数值**。忽略，给出提示

> 8.之前的电话数据区号都是800，现在免费电话的区号还包括877和888并且可能还会增多，那么如何排序呢？如何将免费电话存储在一个集合中，要求可以实现非常快速的查找来判定是否已经存在？

一个想法是把区号作为前缀加入到每个号码后面，然后利用bitmap进行存储，又或者维护另一个区号的映射表，这样可以减少编码的长度。检索的时候就看对应值是不是为1就行。

> !!9.使用更多的空间来换取更少的运行时间存在一个问题：初始化空间本身需要消耗大量的时间。如果数据很稀疏，那么要如何存储？

初始化空间需要大量时间，不过我们的应用只需要其中一点点空间，比如1000000的位图，我们只用到其中的10位，怎样节省时间？题目中提示，可以用额外的正比于向量大小的空间。

解决方法使用了两个额外的向量，`from`和`to`，变量`top`。如果对i位置进行初始化，进行以下步骤：

    from[i] = top;
    to[top] = i;
    data[i] = 0;
    top++;

`from[i]=top`的目的是将`i`在`to`中的索引放入`to`中，`to[top]=i`的意思是，这个`top`位置对应的是`i`，这时data就可以做相应的操作，然后top右移。

判断一个位置是否初始化过的条件是`from[i] < top && to[from[i]] == i`,`from[i]<top`的意思是`from[i]`对应的`to`中的位置已经被处理过了，但是`from[i]`可能是随机值，也只能会小于`top`，那么这时就需要第二个条件了，`to[from[i]] == i`的意思是，`to[from[i]]` 所指向的位置就是`i`，这种双向的指向性的内容确保了能确定`i`位置是否被初始化过。

> 10.如何组织电话号码以允许高效的插入和检索操作？

类似于取快递，根据电话号码的最后一位或者最后两位进行分类，类似于哈希的思想，用顺序遍历来处理碰撞。不能用开头的原因是很多电话号码的前面都是一样的，比如手机号码都是以1开头的。而且最后一位的分布比较随机、均匀。

> 11.汽车每天运送图纸需要一个小时，有什么办法可以减少时间或者费用？

飞鸽传书，答案也是醉

> 12.外太空写字的笔

铅笔

### 深入阅读

Michael Jackson <Software Requirements & Specifications>

程序员的主要问题与其说是技术问题，还不如说是心理问题。很多时候没有办法解决问题是因为想要解决错误的问题。问题的最终解决，是通过打破概念壁垒，进而去解决一个较简单的问题而实现的。

James L. Adams <Conceptual Blockbusting>

## 第 2 章：啊哈！算法

算法与其他哪些深奥的思想一样重要，但在更一般的编程层面上具有更重要的影响

### 三个问题

1. 给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数。在具有足够内存的情况下，如何解决？如果有几个外部的临时文件可用，但是只有几百字节的内存，又该如何解决？
2. 将一个 n 元一维向量向左旋转 i 个位置。简单的代码使用一个 n 元的中间向量在 n 步内完成工作。你能否仅适用数十个额外字节的存储空间，在正比于 n 的时间内完成向量的旋转？
3. 给定一个英语词典，找出其中的所有变位词集合，例如`pots`,`stop`,`tops`互为变位词。

### 问题 1

采用已知包含至少一个缺失元素的一系列整数作为范围，并使用包含所有这些整数在内的文件表示这个范围，通过统计中间点之上和之下的元素来探测范围：或者上面或者下面的范围具有至多全部范围的一半元素。由于整个范围中有一个缺失元素，因此我们所需的那一半范围中必然也包含缺失的元素

### 问题 2

简单的方法就不说了，另一个想法是给出了旋转的位数其实每个字母的最终位置是确定的，只需要一个临时变量，把对应的放过去即可。但是这种方法比较容易出错，不容易维护。

另一个方法是把问题看做数组 ab 转换成 ba。

ab - a'b - a'b' - (a'b')' - ba

    假设原来是 abcdefgh，向左旋转 3 位
    reverse(0, i-1) // cbadefgh
    reverse(i, n-1) // cbahgfed
    reverse(0, n-1) // defghabc

这种方法高效且简短

### 问题 3

直接处理的话，问题非常复杂，需要大量的计算。因为我们只是需要找到同位词，那其实只要把拥有同样字母的单词贴上同样的标志即可。比如说，把每个单词里的字母按照字典序排序，而在具体的标志过程其实也有一些技巧，比如说good可以简化为go2d，这种标识法在长单词多重复时可以减少编码的长度。

具体的映射方式很多，这里不一一赘述

### 习题与个人解答

> 1.考虑查找给定输入单词的所有变位词的问题。仅给定单词和字典的情况下，如何解决该问题？如果有一些时间和空间可以在响应任何查询之前预先处理字典，又会如何？

在给定单词和字典的情况下，遍历字典，计算每个的标签，然后与给定的单词的标签比较。可以预处理的话就好说了，将所有单词按照标签排序，然后可以用equal_range求出区间，O(logN)。

> 2.给定包含 4300000000 个 32 位整数的顺序文件，如何找出一个出现至少两次的整数？

可以类比如何找出没有出现的整数。4300000000 大于int的表示范围。可以先扫描一遍，把第一位为0的和第一位为1的放到两个不同的文件中，看哪个文件里面的数多，就开始处理这个文件，把第二位的0和1的数字放到两个文件中，看哪个的数字多，依此类推，最后肯定得到一个数，他出现了不止一次。

> 3.前面涉及了两个需要精确代码来实现的旋转算法，写出代码。在每个程序中，i 和 n 的最大公约数如何出现

gao函数是那个杂技算法，gaogao是块交换算法。经过简单的测试还没有发现什么问题。n和len的最大公约数就是置换的次数。

    #include<iostream>
    #include<string>
    #include<algorithm>
    using namespace std;
    int gcd( int a, int b ){
        return b==0?a:gcd(b, a%b);
    }
    int gao( int *start, int *end, int n ){
        int len = end - start;
        int d = gcd( n, len );
        for( int i = 0; i < d; i++ ){
            int t = *(start+i);
            int next = i;
            while( (next+n)%len != i ){
                *(start+next) = *(start+(next+n)%len);
                next = (next+n)%len;
            }
            *(start+next) = t;
        }
    }

gaogao函数用到了一个辅助函数，rangeswap，就是将[start1,start1+n)和[start2,start2+n)的值进行交换。

    void rangeswap( int *start1, int *start2, int n ){
        for( int i = 0; i < n; i++ )
            swap( *(start1+i), *(start2+i) );
    }

    void gaogao( int *start, int *end, int shift ){
        int len = end - start;
        shift = ( shift%len + shift )%len;
        if( len <= 1 ) return;
        if( shift <= len / 2 ){
            rangeswap( start, end - shift, shift );
            gaogao( start, end - shift, shift );
        }
        else{
            rangeswap( start, start+shift, len - shift );
            gaogao( end - shift, end, shift - len );
        }
    }

    const int n = 1000000;
    int main(void){
        int a[n];
        for( int i = 0; i < n; i++ )
            a[i] = i;
        gao( a, a+n, 6);
        for( int i = 0; i < n; i++ )
            cout << a[i] << ' ';
        cout << endl;
        return 0;
    }

STL中还有一种更bt的实现方法，algorithm中有个rotate，他用及其简单的代码就实现了循环位移。代码如下：

    template <class ForwardIterator>
    void rotate ( ForwardIterator first, ForwardIterator middle, ForwardIterator last )
    {
      ForwardIterator next = middle;
      while (first!=next)
      {
        swap (first++,next++);
        if (next==last) next=middle;
        else if (first == middle) middle=next;
      }
    }

除了Orz我已经无话可说了。。

> 4.比较三种不同的旋转算法

暂略

> 5.向量旋转函数将向量 ab 变为 ba，如何将 abc 变为 cba？

对每一块儿进行翻转，然后对整体进行翻转即可。

> 6.如何实现以一个名字的按键编码为参数，并返回所有可能的匹配名字的函数？

计算出所有人名的按键信息（标识），然后按照标识进行排序，查询的时候二分即可。答案中提示更多使用的是hash和数据库。

> 7.如何快速转置一个存储在磁带上的 4000x4000 的矩阵，从原来的50个小时缩减到半小时？

可能是因为磁带的读写问题所导致的，具体不清楚

> 8.给定一个 n 元实数集合、一个实数 t 和一个整数 k，如何快速确定是否存在一个 k 元子集，其元素之和不超过 t？

第一感觉想到的是排序，然后看前k个数的和是否不超过t，不超过的话肯定存在。更优的方法用O(N)的选择算法求出第k大的数，然后把数组扫描一遍，求出小于第k大数的数的和sum，加上第k大。这样看似没有什么错误，但是仔细想想，如果第k-1大，第k大，第k+1大的数一样，肿么办？easy~扫描的时候顺便统计小于第k大数的数的个数a，和第k大的数的个数b，嗯，然后如果`a<k-1`,就从b中取出m个，直到`a+m == k-1`。

> 9.顺序搜索和二分搜索代表了搜索时间和预处理时间之间的折中。处理一个 n 元表格时，需要执行多少次二分搜索才能弥补对表进行排序所消耗的预处理时间？

这个，具体让我来算一算

> 10.爱迪生的故事

用水来测体积

## 第 3 章：数据决定数据结构

能用小程序实现，就不要编写大程序。

程序员在节省空间方面无计可施时，将自己从代码中解脱出来，退回起点并集中心力研究数据，常常能有奇效，(数据的)表示形式是程序设计的根本。

下面是退回起点进行思考时的几条原则：

+ **使用数组重新编写重复代码**。冗长的相似代码常常可以使用最简单的数据结构——数组来更好地表述。
+ **封装复杂结构**。当需要非常复杂的数据结构时，使用抽象术语进行定义，并将操作表示为类。
+ **尽可能使用高级工具**。超文本、名字-值对、电子表格、数据库、编程语言等都是特定问题领域中的强大的工具。
+ **从数据得出程序的结构**。彻底理解输入、输出和中间数据结构，并围绕这些结构创建程序。

### 习题与个人解答

> 1.税收分段计费

使用数组来简化循环。数组中每个点表明一个阶段，用level[i]表示阶段i的起始点，tax[i]表示阶段i的税率，用have [i]表示这个阶段已经有的税收，然后得到收入后二分到相应的阶段，计算税收。

> 2.k 阶常系数线性递归

真心没看懂题目，也是醉

> 3.编写一个“banner”函数，该函数的输入为大写字母，输出为一个字符数组，该数组以图形化的方式表示该字母

这个就是用数组画图呗，三维数组即可

> 4.编写处理如下日期问题的函数：给定两个日期，计算两者之间的天数；给定一个日期，返回值为周几；给定月和年，使用字符数组生成该月的日历

    #include<iostream>
    #include<string>
    #include<vector>
    using namespace std;
    int month[13] = {
    0,  31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
    //  1   2   3   4   5   6   7   8   9   10  11  12
    };

    class D{
    public:
        int year,mon,day;// 1900 <= year, 1 <= mon <= 12,
                        // 1 <= day <= 31
        D(){}
        D(int y, int m, int d):
            year(y),mon(m),day(d){}

        int yearday(void){//返回这一天是这一年的第几天
            int sum = day;
            for( int i = 1; i < mon; i++ )
                sum += month[i];
            if( isrun() && mon > 2 )
                sum ++;
            return sum;
        }
        bool isrun( void ){//是否是闰年
            return (year%4==0&&year%100!=0)||(year%400==0);
        }
    };

    int dist( D d1, D d2 ){//两个日期相差的天数
        int sum = -(d1.yearday());
        for( ; d1.year < d2.year ; d1.year++ )
            sum += d1.isrun()?366:365;
        return sum + d2.yearday();
    }

    int xingqiji( D d ){//某一天是星期几
        D temp(1900,1,1);
        return dist( temp, d )%7+1;
    }

    int print(int year, int mon ){//输出某月日历
        D d(year, mon, 1 );
        int week = xingqiji(d);
        int sum = month[ mon ];
        for( int i = 1; i < week; i++ )
            cout << "   ";
        for( int i = 1; i <= sum; i++){
            cout << i << "  ";
            if( week == 7 ){
                week = 1;
                cout << endl;
            }
            else week++;
        }
        cout << endl;
    }

    int main(void){
        D a(2012,6,3);
        cout << xingqiji(a) << endl;
        print(1990,2);
        return 0;

> 5.处理英语中的一小部分连字符问题。

从前到后进行比较，符合一个输出就行。

> 6.题目略

回答略

> 7.其实我没有看懂题目的意思

所以我也没办法回答

> 8.编写一个使用 5 个七段显示数字来显示十六位正整数的程序。输出为一个 5 字节的数组，当且仅当数字 j 中的第 i 段点亮时，字节 j 中的位 i 置 1。

转化为一道题目，是zoj1146

### 深入阅读

数据可以结构化程序，但是只有聪明的程序员才能结构化大型软件系统。

## 第 4 章：编写正确的程序

二分查找并不像想象中简单。

二分搜索的关键思想是如果 t 在 x[0...n-1] 中，那么它就一定存在于 x 的某个特定范围之内。这里使用 mustbe(range) 来表示。逻辑函数 mustbe(l, u) 是说：如果 t 在数组中，t 就一定在(闭区间)范围 x[l...u] 内。

最终的函数为

    l = 0; u = n - 1
    loop
        { mustbe(l, u) }
        if l > u
            p = -1; break;
        m = (l + u) / 2
        case
            x[m] < t: l = m+1
            x[m] == t: P = m; break
            x[m] > t: u = m-1

### 习题与个人解答

> 1.如何证明二分搜索没有运行时错误(例如除数为0、数值溢出、变量值超出声明范围或者数组下标越界)？

为了保证范围不超过范围，我们需要在初始化的时候，让变量不超出范围。这样每次循环得到的新的范围是慢慢缩小的，不会越界。

> !!2.把 t 在数组 x 中地一次出现的位置返回给 p(如果存在多个的话，原始的算法会任意返回其中的一个)。要求代码对数组元素进行对数次比较(在log~2 n 次比较内完成)

    int bs( int *a, int l, int r, int v ){
        while( l <= r ){
            if( a[l] == v ) return l;
            int mid = (l+r)/2;
            if( a[mid] < v ) l = mid+1;
            if( a[mid] == v )r = mid;
            if( a[mid] > v ) r = mid-1;
        }
        return -1;
    }

这个二分可以返回所需要查询的元素第一次出现的位置，如果不存在，则返回-1.在每个循环内，我们假定元素第一次出现的范围是闭区间[l，r]内，当循环体内语句执行完之后，我们得到了一个新的区间。新的区间的范围是一直在收敛的（不会存在r，l执行完循环之后大小没有变化。），所以程序可以终止，得到正确结果。

> 3.编写一个递归的二分搜索程序

    int bss( int *a, int l, int r, int v ){
        if( l > r ) return -1;
        if( a[l] == v ) return l;
        int mid = (l+r)/2;
        if( a[mid] < v ) return bss( a, mid+1, r, v );
        if( a[mid] == v )return bss( a, l, mid, v );
        if( a[mid] > v ) return bss( a, l, mid-1, v );
    }

递归每加深一层，[l,r]的范围就减小。本层的后置条件要和下一层的前置条件吻合。

> 4.验证运行时间是对数的

略

> 5.证明下面的程序在输入 x 为正整数时能够终止

    while x != 1 do
        if even(x)
            x = x/2
        else
            x = 3 * x + 1

找一下规律

从 2 开始: 2 1 4 2 1 4....无法终止
从 3 开始: 3 10 5 16 8 4 2 1 4 2 1 4...无法终止

最终都会归于 214 循环

> 6.咖啡罐问题：给定一个装有一些黑豆子和一些白豆子的咖啡罐以及一大堆额外的黑豆子，重复下面过程直到罐中只剩一颗豆子为止——从罐中选取两个豆子，如果颜色相同，就都扔掉并放入一个额外的黑色豆子，如果颜色不同，将白色的留下，黑色的扔掉。证明该过程会停止，最后留在罐中的豆子颜色与最初白豆子和黑豆子的数量有何函数关系？

每次执行一次，罐子中的豆子数量就减去1,所以此过程可以终止。

化简到最后的阶段

    1 白 1 黑 -> 白
    2 白 -> 黑
    2 黑 -> 白
    可得出以下结论：

如果最后留下的是白色的，那么开始时候白色的个数为奇数，否则为偶数。

> 7.确定点与线段的位置关系

先是给一个线段的范围。然后选取中间的线，看点在他上面还是下面，然后可以缩小一半的查找范围。类似于二分查找

> 8.如何在不改变二次比较次数的前提下让代码运行得更快？

暂时没有想到什么

> 9.证明程序有消息的题目

两个n维的向量相加。初开始时：i=0表示前i个维度的都已经计算好了。在循环之中，计算一个维度，然后i加一，计算下一个维度，每个循环结束表明前i个维度已经计算完毕。i一直在增大，证明这个过程是可以终止的。当最后一个循环执行完毕的时候，i的值是n，表明前n个维度已经计算好了。所以其代码是正确的。

求x数组的最大值。初开始时候，max=x[0]表示最大值是第一个数，i=1表示前i个数的最大值已经求出。每次循环时候，如果有比max大的数，就替换，当循环结束时候，前i个数的最大值就知道了。当整个过程结束时，i==n，所以前n个数的最大值可以求出。

当循环找个一个t的时候，就停止循环，或者当i超出范围的时候停止。i在每一次循环的时候值都增加，所以这个算法是可以结束的。当超出范围的时候，返回-1，否则返回的就是第一次出现的位置，因为i的值是从小到大递增的。

每次递归，问题的规模都是缩小的，所以问题可以在有限步骤内结束。每次递归完成一次，就可以得到上次层想要的运算结果，接着向上传递。
