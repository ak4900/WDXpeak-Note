# 算法导论(第三版)

<!-- MarkdownTOC -->

- 需要重点理解的内容
- 第 1 章：算法在计算中的作用
- 第 2 章：算法基础
    - 2.1 插入排序
    - 2.2 分析算法
    - 2.3 设计算法
        - 归并排序
        - 冒泡排序
- 第 3 章：函数的增长
- 第 4 章：分治策略
    - 最大子数组问题(maximum subarray)
    - 矩阵乘法的 Strassen 算法

<!-- /MarkdownTOC -->

## 需要重点理解的内容

+ 归并排序
+ 最大子数组问题



## 第 1 章：算法在计算中的作用

许多有趣算法问题所共有的两个特征：

1. 存在许多候选解，但绝大多数候选解都没有解决手头的问题。寻找一个真正的解或一个最好的解可能是一个很大的挑战。
2. 存在实际应用。

## 第 2 章：算法基础

### 2.1 插入排序

![ia1](./_resources/ia1.jpg)

    // 插入排序
    void INSERTION_SORT(int *A, int length){
        for (int j = 1; j < length; j++){
            int key = A[j];
            int i = j - 1;
            while(i >= 0 && A[i] > key){
                A[i+1] = A[i];
                i--;
            }
            A[i+1] = key;
        }
    }

**循环不变式**主要用来帮助我们理解算法的正确性。关于循环不变式，我们必须证明三条性质：

+ **初始化**：循环的第一次迭代之前，它为真
+ **保持**：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真
+ **终止**：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的

本书中在退出循环后，循环计数器保持其值

### 2.2 分析算法

我们假定一种通用的单处理器计算模型——随机访问机(random-access machine, RAM)来作为算法分析的模型，这里指令一条接一条执行，没有并发操作。具体的一些细节不必过分考究，只要一直保持统一即可，然后尽量绕开一些模棱两可的运算。

本书中主要只求**最坏运行时间**，因为：

+ 一个算法的最坏情况运行时间给出了任何输入的运行时间的一个上界。知道了这个界，就能确保该算法绝不需要更长的时间
+ 对某些算法，最坏情况经常出现
+ 平均情况往往与最坏情况大致一样差

在某些特定情况下，我们会对一个算法的**平均情况**运行时间感兴趣。平均情况分析的范围有限，因为对于特定的问题，什么构成一种“平均”输入并不明显。我们常常假定给定规模的所有输入具有相同的可能性。实际上，该假设可能不成立，但是，有时可以使用**随机化算法**，它做出一些随机的选择，以允许进行概率分析并产生某个**期望**的运行时间。

我们真正感兴趣的是运行时间的**增长率**或**增长量级**。用`O(n)`这样的表示。

### 2.3 设计算法

**分治法**

许多有用的算法在结构上是**递归的**：为了解决一个给定的问题，算法一次或多次递归调用其自身以解决紧密相关的若干子问题。分治模式在每层递归都有三个步骤：

+ **分解**原问题为若干子问题，这些子问题是原问题的规模较小的实例
+ **解决**这些子问题，递归地求解各子问题。如果子问题的规模足够小，直接求解
+ **合并**这些子问题的解成原问题的解

#### 归并排序

![ia2](./_resources/ia2.jpg)

![ia3](./_resources/ia3.jpg)

    void MERGE(int *A, int p, int q, int r){
        int i, j;
        int n1 = q - p + 1;
        int n2 = r - q;
        // 这里就不新开数组了，直接开俩长度为10的用作示意
        int L[10] = {0};
        int R[10] = {0};

        for (i = 0; i < n1; i++){
            L[i] = A[p + i - 1];
        }

        for (j = 0; j < n2; j++){
            R[j] = A[q + j];
        }

        L[n1] = 9999;
        R[n2] = 9999;

        i = j = 0;

        for (int k = p - 1; k < r; k++){
            if (L[i] <= R[j]){
                A[k] = L[i];
                i++;
            }
            else{
                A[k] = R[j];
                j++;
            }
        }
    }

    void MERGE_SORT(int *A, int p, int r){
        if (p < r){
            int q = (p+r)/2;
            MERGE_SORT(A, p, q);
            MERGE_SORT(A, q+1, r);
            MERGE(A, p, q, r);
        }
    }

注意一下下标的问题，统一即可。

#### 冒泡排序

![ia4](./_resources/ia4.jpg)

    void BUBBLE_SORT(int *A, int length){
        int temp = 0;
        for(int i = 0; i < length - 1; i++){
            for (int j = length - 1; j > i + 1; j--){
                if (A[j] < A[j-1]){
                    temp = A[j];
                    A[j] = A[j-1];
                    A[j-1] = temp;
                }
            }
        }
    }

## 第 3 章：函数的增长

这一章主要讲的是怎么计算复杂度，暂略

## 第 4 章：分治策略

当子问题足够大，需要递归求解时，我们称之为**递归情况(recursive case)**。当子问题变得足够小，不再需要递归时，我们说递归已经“触底”，进入了**基本情况(base case)**

### 最大子数组问题(maximum subarray)

寻找数组 A 的和最大的非空连续子数组。

假定我们要寻找子数组 A[low...high] 的最大子数组，那么找到中央位置 mid，然后求解两个子数组 A[low...mid] 和 A[mid+1...high]。A[low...high]的任何连续子数组 A[i...j] 所处位置必然是以下三种情况之一：

+ 完全位于子数组 A[low...mid]中，因此 low <= i <= j <= mid
+ 完全位于子数组 A[mid+1...high]中，因此 mid < i <= j <= high
+ 跨越了中点，因此 low <= i <= mid < j <= high

因此，只要找到这三种情况的和的最大者，就是最大子数组了，具体可以用递归做，也有其他更加巧妙一些的方法，之后需要重点理解

### 矩阵乘法的 Strassen 算法


