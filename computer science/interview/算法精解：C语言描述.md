## 算法精解：C语言描述

##### (美)Kyle Loudon

  

  存储空间分配

  

2015-01-28 13:04:25

必须要记住的一点是：当声明一个指针时，仅仅只是为指针本身分配了空间，并没有为指针所引用的数据分配空间。而为数据分配存储空间有两种方法：一种是直接声明一个变量
；另一种是在运行时动态地分配存储空间（例如：使用malloc或realloc）。

  

  数据集合与指针的算术运算

  

2015-01-28 13:07:38

指针在C语言中最常见的用途就是用来引用数据集合。数据集合是由多个相关联的元素构成的数据。C语言支持两种数据集合：结构和数组。（虽然联合与结构类似，但一般它单
独被归为一类。）

  

2015-01-28 13:08:26

结构ListElmt也指出了关于结构指针的另一个重要方面：结构不允许包含自身的实例，但可以包含指向自身实例的指针。这种编程思想非常重要，因为很多数据结构都可
能是由它自身的结构变量所组成，例如，在一个链表中，每个ListElmt结构都指向另一个ListElmt结构。有些数据结构甚至会包含多个由自身结构类型组成的结
构，例如，在一个二叉树中（见第9章），每个节点同时指向其他两个二叉树的节点。

  

  作为函数参数的指针

  

2015-01-28 13:09:41

在C语言的函数调用中指针起着至关重要的作用。最重要的是，指针支持将参数作为引用传递给函数（即按引用调用）。按引用传递参数时，当函数改变此参数时，这个被改变参
数的值会一直存在，甚至函数退出后都仍然存在。相对而言，当按值调用传递函数时，此时值的改变只能持续到函数返回时。无论是否要改变函数的输入输出参数，使用指针传递
大容量复杂的函数参数也是十分高效的手段。这种方法高效的原因就在于，我们只是传递一个指针而不是一个数据的完整副本到函数中，这样可以大大地节省内存空间。

  

  泛型指针与类型转换

  

2015-01-28 13:15:43

通常情况下，C只允许相同类型的指针之间进行转换。例如：一个字符型指针sptr（一个字符串）和一个整型指针iptr，我们不允许把sptr转换为iptr或把ip
tr转换为sptr。但是，泛型指针能够转换为任何类型的指针，反之亦然。因此，如果有一个泛型指针gptr，就可以把sptr转换为gptr或者把gptr转换为s
ptr。在C语言中，通常声明一个void指针来表示泛型指针。

  

  泛型指针与类型转换

  

2015-01-28 13:16:55

当转换指针时，我们对内存中的数据对齐方式必须特别注意。具体来说，我们需要知道，指针的类型转换会破坏计算机本身的对齐方式。很多计算机对对齐的方式有要求，以便某
些硬件的优化可以使访问内存更有效率。例如，一个系统可能要求所有整数按字边界对齐。所以，如果有一个非按字对齐的void指针，当将它转换为一个整型指针并试图获取
它的值时，程序可能在运行时出现异常。

  

  函数指针

  

2015-01-28 13:26:45

函数指针是指向可执行代码段或调用可执行代码段的信息块的指针，而不是指向某种数据的指针。函数指针将函数当做普通数据那样存储和管理。函数指针有一种固定的形式，就
是包含一个确定的返回值类型和若干个函数参数。声明一个函数指针看起来与声明一个函数非常类似，只是在函数名之前有一个表示指针的星号（*），并且函数名和星号会用圆
括号括起来。

  

  基本递归

  

2015-01-28 13:30:54

在计算机科学领域中，递归是通过递归函数来实现的。递归函数是一种可以调用自身的函数。每次成功的调用都使得输入变得更加精细，使我们越来越接近问题的答案。大多数开
发者都喜欢将大型的问题分解成一些小型的问题，然后分别编写不同的函数去处理它们。然而，许多开发者却并不习惯于用单一函数递归的方式解决大型的问题。诚然，以这种方
式看待问题需要一定的适应过程。

  

2015-01-28 13:31:13

尾递归  
递归的一种形式，这里编译器会为此产生优化的代码。大多数现代的编译器能够识别尾递归。为此，只要条件允许我们都应该利用这个特性。

  

2015-01-28 13:34:13

栈是用来存储函数调用信息的绝好方案，这正是由于其后进先出的特点（见第6章）精确满足了函数调用和返回的顺序。然而，使用栈也有一些缺点。栈维护了每个函数调用的信
息直到函数返回后才释放，这需要占用相当大的空间，尤其是在程序中使用了许多递归调用的情况下。除此之外，因为有大量的信息需要保存和恢复，因此生成和销毁活跃记录需
要耗费一定的时间。如此一来当函数调用的开销变得很大时，我们就需要考虑应该采用迭代的方案。幸运的是，我们可以采用一种称为尾递归的特殊递归方式来避免前面提到的这
些缺点。

  

  尾递归

  

2015-01-28 13:34:28

如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，
这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。

  

2015-01-28 13:36:41

当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活跃记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语
句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了
，这使得实际的运行效率会变得更高。因此，只要有可能我们就需要将递归函数写成尾递归的形式。

  

  最坏情况分析

  

2015-01-28 13:41:22

最坏情况可以告诉我们算法性能的上限。分析一个算法的最坏情况可以保证在任何情况下此算法的表现都不会比最坏情况差，而其他情况肯定比最坏情况要好。

  

  O表示法

  

2015-01-28 13:42:25

常数项用O（1）表示。当分析一个算法的运行时间时，如果知道无论它处理多大的数据量，它都至少得消耗一段固定的时间，那么就可以用常数项表示此固定的时间。

  

2015-01-28 13:42:48

常量因子往往被忽略。当分析一个算法的运行时间时，如果有某些任务都将执行相同数量的次数，就可以运用此规则。例如：有三个任务的运行时间为T（n）=n，运行结果表
示为O（3n），根据规则可以简化为O（n）。

  

2015-01-28 13:42:56

加法运算取最大值。当分析一个算法的运行时间时，如果一个任务在另一个任务之后顺序执行，可以运用此规则。例如，有两个顺序执行的任务，其运行时间分别为：T1（n）
=n和T2（n）=n2，运行结果表示为O（n）+O（n2），根据规则，可以简化为O（n2）

  

2015-01-28 13:43:20

乘法结果不需要改变，但往往可以用更紧凑的方法表示。当分析一个算法的运行时间时，如果一个任务的执行引起了另一个任务的迭代执行，可以运用此规则。例如：在一个嵌套
循环中，外层迭代为T1，内层迭代为T2，如果T1（n）=n,T2（n）=n，那么运行结果表示为O（n）O（n）或O（n2）。

  

  问与答

  

2015-01-28 13:45:41

按算法的复杂度从低到高排列为：O（1）、O（lg n）、O（n）、O（n lg n）、O（n2）、O（n2 lg
n）、O（n3）、O（2n）、O（3n）、O（n!）。

  

  相关主题

  

2015-01-28 13:46:15

NP完全问题  
没有已知的求解多项式时间的算法，但也无法证明此多项式不存在，这类问题称为NP完全问题。所以，长久以来NP完全问题一直是计算机科学领域令人困惑和烦恼的问题之一
。多项式时间算法的复杂度小于或等于O（n2），其中k是常数。很多有用且看似困难的问题都归为此类，例如：旅行商问题

  

  问与答

  

2015-01-28 13:54:12

当我们期望进行频繁的插入和删除操作时，链表比数组更有优势。然而，当我们期望进行随机访问的次数高于插入和删除操作的次数时，数组就显得更有优势了。随机访问是数组
的强项，因为它们的元素在内存中是连续排列的。这种连续的排列方式使得数组中的任何元素能够在O（1）的时间内通过其索引访问。回顾一下访问链表中元素的方法，我们必
须得有一个指向元素的指针。如果我们对访问元素的方式不甚了解，那么要获取某个指向特定元素的指针的代价将非常高。在实践中，对于许多应用来说，我们至少需要遍历链表
的一部分。如果存储数据的总量是恒定的，则数组也有更大的优势，因为它们不需要增加额外的指针来使得它们所有的元素“链接”起来。

  

  第6章 栈和队列

  

2015-01-28 13:58:38

事件处理是实时编程的重要组成部分。在实时系统中，当事件频繁发生时，系统往往并没有完全准备好去处理它们。而队列可以记录事件的信息，并在稍后将发生的事件按接收顺
序一一处理。

  

2015-01-28 14:01:46

生产者-消费者问题  
这是进程间协同合作的一个经典模型。其中，在一个进程中生产者向一个被其他进程共享的队列中写入数据，而同时消费者从此队列中读出数据。生产者-
消费者问题是一个经典的学习案例，因为很多实际应用都可以用此模型来表述。

  

  栈的实现与分析

  

2015-01-28 14:02:57

实现栈的方法有很多，其中之一是用链表来实现。可以通过typedef Stack to List这种简单的方法来做到这一点（见示例6-1）。这种方法不仅简单，
而且可以使栈具有多态的特性。通俗地讲，多态通常是面向对象语言的一种特性，它允许某种类型的对象（变量）在使用时用其他类型的对象（变量）代替。这意味着，除了使用
栈本身的操作外，还可以使用链表中的操作，这是因为栈本身就是一种链表，它与链表有相同的特性。因此，很多时候可以像使用链表一样使用栈。

  

  相关主题

  

2015-01-30 09:39:57

多态  
某种类型的对象（变量）可以用其他特定的对象（变量）替代使用，这两种对象（变量）之间有某些相同的特性。多态是面向对象语言的重要组成部分。然而，在一些内在并不支
持多态的语言中，我们在某种程度上仍然可以通过使用一些特殊技术来提供这种多态的特性。

  

2015-01-30 09:40:49

双向队列  
通常简称为deque（发音同"decks"）。双向队列操作更加灵活，它能够在队列的头部和尾部都进行插入和删除操作。

  

  第7章 集合

  

2015-01-30 09:41:16

集合是不同对象（称为成员）的无序聚集。由于元素之间彼此相关联，因此可以理解为归聚在一起的成员组合。集合的两个重要特点是：第一，成员是无序的，第二，每个成员都
只在集合中出现一次。集合是离散数学中的重要部分，离散数学与计算机科学之间有着很深的渊源。在计算机科学中，我们使用集合来归类数据，尤其是当我们计划以后将其与其
他数据相关联时。

  

  Set示例：集合覆盖

  

2015-01-30 09:46:02

集合覆盖是一种优化求解问题，对很多组合数学和资源选择问题给出了漂亮的抽象模型。问题是这样的：给定一个集合S，集合P由集合S的子集A1到An组成，集合C由集合
P中的一个或多个子集组成。如果S中的每个成员都包含在C的至少一个子集中则称集合C覆盖集合S。此外，C包含的P的子集应该越少越好。

  

  第8章 哈希表

  

2015-01-30 09:52:08

哈希表支持一种最有效的检索方法：散列。从根本上来说，一个哈希表包含一个数组，通过特殊的索引值（键）来访问数组中的元素。哈希表的主要思想是通过一个哈希函数，在
所有可能的键与槽位之间建立一张映射表。哈希函数每次接受一个键将返回与键相对应的哈希编码或哈希值。键的数据类型可能多种多样，但哈希值的类型只能是整型。

  

  链式哈希表的例子：符号表

  

2015-01-30 09:56:05

在编译的过程中，编译器访问符号表也分为几个阶段。其中一个部分称为词法分析器，用来插入符号。词法分析器是编译器的重要部分，它负责将源代码中有组织的字符转换为有
意义的字符串，称为语义转换。这些转换后的字符串称为标记（token），然后传到解释器进行解析。解释器进行句法分析。送入词法分析器的符号通常是字符流，词法分析
器将字符流分割出来存入符号表中。词法分析器存储两种重要的属性，一个是符号的语义，另一个是构成语义的标记类型（例如，字符是一个标识符还是一个操作符）。

  

  二叉树介绍

  

2015-02-02 16:56:50

如何遍历二叉树的结点可能并不是很明显。事实上，可以采取许多种方法来完成。一般情况下，会采用下列4种树的周游算法：先序遍历、中序遍历、后序遍历以及层级遍历。

  

2015-02-02 16:57:17

先序遍历  
给定一棵子树，按照先序遍历的方式，首先访问它的根结点，然后是左子结点，最后是右子结点。由于按照从左到右的方式依次遍历各个子树，因此以相同的方式将左子结点和右
子结点当做新的子树的根。

  

2015-02-02 16:57:29

中序遍历  
给定一棵子树，按照中序遍历的方式，首先访问左子结点，然后是根结点，最后是右子结点。由于按照从左到右的方式依次遍历各个子树，因此以相同的方式将左子结点和右子结
点当做新的子树的根。

  

2015-02-02 16:57:37

后序遍历  
给定一棵子树，按照后序遍历的方式，首先访问左子结点，然后是右子结点，最后是根结点。由于按照从左到右的方式依次遍历各个子树，因此以相同的方式将左子结点和右子结
点当做新的子树的根。

  

  问与答

  

2015-02-02 16:59:29

问：同双向链表类似，一些树除了维护从父结点指向子结点的正常指针外，也维护了从子结点指回它们父结点的指针。还有一些树中在兄弟结点之间也维护互相关联的指针。为什
么要这么做呢？  
答：一般来说，维护附加的指针为遍历树时提供了更加灵活的方式。比如，维护父结点与子结点之间的指针使我们既能够自上而下也能够自下而上遍历这棵树。维护兄弟结点之间
的指针，则使我们能够方便地遍历所有子结点而不必先访问其父结点。连接兄弟结点带来的好处在B+树中可以找到，这是一种使用指针将叶子结点连接在一起的平衡搜索树。通
过链接叶子结点，能够有效地在树的最底端形成一个链表。这提供了一种按照顺序查找特定的结点，并检索要么在其之前或在其之后的其他结点的高效方法。数据库系统采用这种
方法来同时支持高效的随机和顺序访问。当然，缺点就是多了一些保存指针的开销，而且在插入和移除子结点时，管理兄弟结点间的指针比较复杂。

  

2015-02-02 17:01:20

问：在二叉搜索树中我们如何找到最小的结点？在最坏的情况下，在非平衡和平衡二叉搜索树中该操作的时间复杂度是多少？如何在二叉搜索树中找到最大的结点呢？时间复杂度
又为多少？  
答：二叉搜索树中的最小结点是最左边的那个叶子结点。要定位到该结点，从根结点开始通过左指针逐层下降，直到到达该分支的边缘。在非平衡的二叉搜索树中，在最坏的情况
下这需要O（n）的时间，n代表树中的结点个数。这种情况发生在该树只有一个单独的左分支时。但是，如果保持树的平衡性，则没有哪一个分支将超过lg
n个结点的长度，因而查找最小结点的复杂度就成为O（lg
n）。查找最大结点的处理过程类似，只是最大的结点位于最右端的叶子结点上。时间复杂度同查找最小的结点一样

  

2015-02-02 17:05:54

问：何时应该选择使用分支因子相对较大的树而不是二叉树呢？举例说明。  
答：对于给定的结点个数，分支因子大能够保持这棵树的高度较低，也就使树能够保持相对的平衡性。因此，在对树的高度尤其敏感的应用中，采用分支因子较大的树是更好的选
择，搜索树就是个很好的例子，这也是二叉树通常都用于内存中查找操作的原因。尽管在一般情况下分支因子较大的树在内存中的性能并没有显著的提升，但是，当在速度相对较
慢的辅助存储空间（比如闪存）内执行查找操作时，分支因子较大的树在性能上会有明显的区别。在这种情况下，一般会采用某种类型的B树

  

  相关主题

  

2015-02-02 17:10:04

红黑树  
红黑树是每个结点都带有颜色属性的自平衡二叉搜索树，结点颜色要么为红要么为黑。通过在分支中规定结点着色的规则，红黑树能够确保每一个分支都不会长于其他分支的2倍
。红黑树的最长运行时间是T（n）=2klgn，这里n是树中结点的个数，k为某个常量。而完全平衡二叉树的搜索时间为T（n）=klgn。

  

2015-02-02 17:10:17

Trie树  
Trie搜索树主要用来查找变长字符串的组合。从概念上说，Trie树中每一层的结点代表正在搜索的字符串中某个特定位置的所有可能字符。比如，紧跟在根结点下方的结
点代表字符串中位置1处的所有可能字符，下一层的结点代表字符串位置2处的所有可能字符，以此类推。因此，要查找一个字符串，从根结点开始，每下一层都包含待查找的字
符串的下一个字符。这个过程使得搜索的时间只与待查找字符串的长度相关，而与待查找的字符串总数无关。

  

2015-02-02 17:10:24

B树，B+树以及B*树  
数据库系统通常使用B树来提高访问辅助存储设备上的数据的性能。一般来说，通过优化手段使得结点大小和辅助存储设备的块大小保持一致。所有类型的B树都是平衡的，且一
般都有较大的分支因子。这使得树的高度较小，于是为了得到某条记录必须遍历的层级数减少了，从而减少了I/O操作带来的开销。

  

  堆的描述

  

2015-02-02 17:12:25

堆的描述  
堆是一棵二叉树，通常其子结点存储的值比父结点的值小。所以，根结点是树中最大的结点。同样，我们也可以让堆向另一种方向发展，即每个子结点存储的值比父结点的值大。
这样根结点就是树中最小的结点。这样的二叉树是局部有序的，任何一个结点与其兄弟结点之间都没有必然的顺序关系，但它与其父子结点有大小顺序关系。子结点比父结点小的
堆称为最大值堆（见图10-1），这是因为根结点存储该树所有结点的最大值。反之，子结点比父结点大的堆称为最小值堆。

  

  优先队列的描述

  

2015-02-02 17:13:11

优先队列的描述  
优先队列将数据按照优先级顺序排列。一个优先队列由许多有序的元素构成，所以优先级最高的元素可以有效而快速地确定。例如，我们看一组用来做负载均衡的服务器，时时观
察它们的使用情况。当连接请求到达时，优先队列可以告知当前哪个服务器是处理此连接请求的最佳服务器。在这种情况下，最空闲的服务器获取的优先级最高，因为它可以最好
地处理服务请求。

  

  第11章 图

  

2015-02-02 17:13:41

在计算机科学领域中，图是最为灵活的数据结构之一。事实上，大多数其他的数据结构也都能表示为图的形式，尽管按照这种方法表示它们通常会变得更加复杂。一般来说，图在
定义对象之间的关系或联系这类问题上能够作为一种模型来帮助我们。图中的对象可能是某种实际的实体，比如网络中的结点或者河流中的岛屿，但这也并非必须如此。通常，对
象都不是那么具体，比如某个系统中的状态或数据库中的业务。相同点只是对象之间的关联和联系。网络中的结点是物理上相连接的，但系统中状态之间的关系可能只是简单地表
示为了达到下一个状态在当前所做出的决策。无论是什么情况，图的模型都很有用，能够解决许多有趣的计算问题。

  

  第12章 排序和搜索

  

2015-02-02 17:14:34

总的来说，排序算法分为两大类：比较排序和线性时间排序。比较排序依赖于比较和交换来将元素移动到正确的位置上。令人惊讶的是，并不是所有的排序算法都依赖于比较。对
于那些确实依赖于比较来进行排序的算法来说，它们的运行时间往往不可能小于O（nlg n）。对于线性时间排序，从它的名字就可以看出，它的运行时间往往与它处理的数
据元素个数成正比，即为O（n）。遗憾的是，线性时间排序依赖于数据集合中的某些特征，所以我们并不是在所有的场合都能够使用它。某些排序算法只使用数据本身的存储空
间来处理和输出数据（这些称为就地排序），而有一些则需要额外的空间来处理和输出数据（虽然可能最终结果还是会拷贝到原始的内存空间中）。

  

2015-02-02 17:15:33

搜索就是在一个数据集中找到一个元素的位置，它可用于任何任务中。一种最简单的、不需要费任何脑筋的搜索方法是：简单地从数据集的一端查找到另一端。这就是所谓的线性
搜索。通常，线性搜索用在那些对随机访问支持得不太好的数据结构中，例如：链表（见第5章）。另一种方法是使用二分查找，这会在本章中介绍。还有一些搜索方法专门用于
特定的数据结构，例如哈希表（见第8章）和二叉树（见第9章）。

  

  归并排序的实现与分析

  

2015-02-02 17:25:26

归并排序的实现与分析  
归并排序本质上是将一个无序元素集分割成许多个只包含一个元素的集，然后不断地将这些小集合并，直到一个新的大有序数据集生成。在以下介绍的实现方法中，data最初
包含size个无序元素，并存放在单块连续的存储空间中。因为归并过程需要额外的存储空间，所以mgsort要为合并过程分配足够的内存。在mgsort返回时，最终
通过合并得到的有序数据集将会拷贝回data。

  

  计数排序的描述

  

2015-02-02 17:28:17

计数排序的描述  
计数排序是一种高效的线性排序，它通过计算一个集合中元素出现的次数来确定集合如何排列。不同于之前介绍的一些算法是基于比较的，计数排序不需要进行元素比较，而且它
的运行效率要比效率为O（nlg n）比较排序高。

  

  基数排序的描述

  

2015-02-02 17:31:11

基数排序的描述  
基数排序是另外一种高效的线性排序算法。其方法是将数据按位分开，并从数据的最低有效位到最高有效位进行比较，依次排序，从而得到有序数据集合。我们来看一个例子，用
基数排序对十进制数据{15,12,49,16,36,40}进行排序。在对个位进行排序之后，其结果为{40,12,15,16,36,49}，在对十位进行排序之
后，其结果为{12,15,16,36,40,49}。  
有一点非常重要，在对每一位数值进行排序时其排序过程必须是稳定的。因为，一旦一个数值通过较低有效位的值进行排序之后，此数据的位置不应该改变，除非通过较高有效位
的值进行比较后需要它调整位置。例如，在以上的例子中，整数12和15的十位数都包含1，当对其十位数进行排序时，一个不稳定的排序算法可能不会维持其在个位数排序过
程中的顺序。而一个稳定的排序算法可以保证它们不重新排序。基数排序会用到计数排序，因为对于基数排序来说，除了稳定性，它还是一种线性算法，且必须知道每一位可能的
最大整数值。

  

  问与答

  

2015-02-02 17:36:49

问：假设有一个全球性投资公司，需要将其客户按照名字排序。由于数据量巨大，因此我们不可能一次将所有数据读入内存。这种情况下应该选择哪种排序算法？  
答：归并排序。除了它的排序时间可以维持在O（nlg
n）之外，它以可预见的方式合并有序分区和数据，这种特性让我们很容易管理数据，使这些数据可以在内存中高效地读入读出。

  

2015-02-02 17:40:32

问：假设我们正在一个用户界面中维护一个有序元素的列表。这个列表相对较小，而且其元素由用户一个一个插入进去。这种情况下应该选择哪种排序算法？  
答：插入排序。对一个有序队列使用插入排序的时间复杂度为O（n）。

  

2015-02-02 17:40:40

问：假设在生物研究中，我们用1000万个80个字符宽的字符串来表示DNA的信息。这种情况下应该选择哪种排序算法？  
答：基数排序。基数排序的性能表现取决于基值的选择和空间的限制。然而，选择基数排序的一个重要考量因素是：数据集中的元素是固定大小的，而且能够分割为更小的整型变
量。

  

2015-02-02 17:43:03

问：假设有10 000个C数据结构，它们包含一个航空公司的航班时刻表，我们需要此时刻表进行排序。这种情况下应该选择哪种排序算法？  
答：快速排序。在一般情况下它是最好的排序算法，而且对于处理中到大型的数据非常高效。

  

  第13章 数值计算

  

2015-02-02 17:46:13

数值计算是指在数值分析领域中的算法。数值分析是专门研究和数字以及近似值相关的数学问题，数值计算在数值分析的研究中发挥了特别重要的作用。计算机特别适合于做数值
分析研究，因为许多这类问题都会涉及很多常见的数学运算，大量用到计算机。在计算机的早期时代，计算机成了一种垄断式的工具，被科学家用来解决这类因为太过于密集和复
杂而无法手工计算的问题。甚至在今天，数值分析领域的问题仍然占用了当今世界上最大型计算机的部分运算周期。因此，数值分析是一个巨大的课题，许多数值计算方法和它们
所解决的数学问题一样相当的复杂。

  

2015-02-02 17:50:02

多项式插值  
求函数近似值的一种方法。其中函数值仅在几个点上已知。该算法的基础是建立级数小于等于n的一个插值多项式pn（z），其中n+1是已知函数值的点的个数。

  

2015-02-02 17:50:05

最小二乘估计法  
给定函数y（x）=b1x+b0，用来确定b1和b0的估计器方法，使得y（x）是n个点（x0,y0）,……,（xn-1,yn-1）的集合的最佳拟合线。最佳拟合
线使用最小二乘估计法来最小化每个点（xi,yi）,i=0,……,n-1与沿y（x）的相应点（xi,y（xi））之间的垂直距离的平方之和。

  

2015-02-02 17:50:11

方程求解  
找到f（x）=0的根的过程。对于某些方程可以求出精确解，而大多数时候则必须采用近似法。

  

2015-02-02 17:50:17

线性回归模型  
一个独立变量x和依赖于它的一个变量y之间的线性关系的统计模型。在未经试验观察的情况下，最小二乘法有助于预测出x和y之间的关系。

  

2015-02-02 17:50:20

曲线拟合  
曲线拟合是指将一系列的点拟合为一条曲线的过程。如果某些已知坐标的点刚好落在需要拟合的曲线之上，只要得到足够多这样的点，那么利用插值法就有助于绘制出平滑的曲线
。

  

2015-02-02 17:50:23

散点图  
散点图是一种统计工具，用来帮助确定一个独立的变量x和依赖于x的变量y之间的关系。采用最小二乘估计器，通过一个线性形式的散点图来帮助我们绘制出一条最佳拟合线。

  

2015-02-02 17:50:26

函数逼近  
当一个函数在某个点的确切值未知时，用来估计其值的过程。这可以通过建立一个适当的插值多项式来完成。

  

  第14章 数据压缩

  

2015-02-02 17:51:03

数据压缩是一个减小数据存储空间的过程。它是信息理论最重要的成果之一，它利用数学工具采用各种方法来管理和处理信息。数据压缩包括两个过程：一个过程是，压缩或编码
数据，数据大小减小；另一个过程是，解压缩或解码数据，还原到数据本身的状态。

  

2015-02-02 18:42:29

本章重点介绍无损压缩，实现无损压缩主要有两种方法：最小冗余编码和基于字典的方法。最小冗余编码使用更少的位对出现更为频繁的字符进行编码，用较长的位对出现频率较
低的字符进行编码。在基于字典的方法中，其通过对数据进行符号编码，来代替那些重复多余的短语。

  

2015-02-02 18:48:23

LZ77（Lempel-Ziv-1977）  
LZ77是基于字典法的压缩方法。它使用一个滑动窗口和一个前向缓冲区对数据中已出现过的词组进行编码。一般情况下，LZ77的压缩率要比霍夫曼编码更好，但是它需要
更多的压缩时间。同时它的解压缩时间还比较快。

  

  问与答

  

2015-02-02 18:50:12

问：在某些情况下，压缩数据可能会产生不太优的结果。如果使用霍夫曼编码的方法，在什么情况下可能出现这种不好的结果？  
答：霍夫曼编码的压缩效率取决于数据中符号出现的不同频率。如果几乎所有符号都有大概相同的频率，那么压缩的结果不佳。同样，用霍夫曼编码压缩小量的数据时，其压缩效
果也不好。在这种情况中，表中表头所占用的空间对数据的压缩率会产生负面影响。幸运的是，这些限制条件通常都不是问题，因为在大多数的数据中符号都不会是均匀分布的，
而且我们通常对压缩小量的数据不感兴趣。

  

2015-02-02 18:50:29

问：和霍夫曼编码一样，在某些情况下使用LZ77算法也可能产生不佳的压缩结果。请说明一些这样的情况。  
答：LZ77算法的压缩效率取决于能够被短语标记编码的符号序列的数量。如果产生了大量的符号标记，而只产生了很少的短语标记来表示大多数的短语，那么压缩效果不佳。
如果符号标记的数量过多，甚至可能出现压缩后的数据要大于原始数据的情况。出现这种情况往往是由于滑动窗口太小，没有有效地利用重复出现的词组所带来的优势。

  

  相关主题

  

2015-02-02 18:52:09

有损压缩  
这是一种广泛的数据压缩方法，在解压缩后它无法完整地还原原始数据。有损压缩主要应用于图像和音频领域，因为如果精确控制数据的丢失，在这两个领域损失一定的数据来换
取更大的压缩比是值得的。

  

2015-02-02 18:52:18

统计模型  
它是基于最小冗余编码的数据压缩方法背后的引擎。本章展现的是阶值为0的模型，它只决定数据中任何一个符号的出现概率。高阶模型会观察符号组合的概率，从而更精确地获
取数据的熵。例如，如果在文本数据中遇到了符号"Q"，在很多语言中，"Q"后紧接着是符号"U"的概率非常大。高阶模型就是用来考虑这样的情况。

  

2015-02-02 18:52:31

香农费诺编码  
它是最小冗余编码的首个实现方法。有趣的是，它产生于还没有计算机的20世纪40年代，是二战期间信息论发展的产物。香农费诺编码与霍夫曼编码类似，但是它是由上而下
构造树，而不是从下往上。

  

2015-02-02 18:52:45

算术编码  
这是一种流行的压缩方法，用来解决由霍夫曼编码带来的其熵是小数的不准确问题。算术编码通过将数据编码成单个很长的浮点值来避免这个问题，而这个值也可以唯一地解码。

  

  DES算法介绍

  

2015-02-02 18:54:04

DES（Data Encryption Standard）  
最流行的对称加密算法之一。目前理所当然地认为DES是相对安全的，但随着当今计算机的处理速度越来越快，使得该算法变得越来越不安全。DES是一种效率较高的加密算
法，甚至可以直接在软件中实现。

  

2015-02-02 18:54:08

RSA（Rivest-Shamir-Adleman）  
最流行的公钥加密算法之一。RSA被认为是非常安全的加密算法，但是处理速度比DES要慢得多。因此，它常用来加密较小规模的数据，比如针对其他类型加密的密钥，以及
数字签名信息。

  

2015-02-02 18:58:11

DES（Data Encryption Standard）是最为流行的对称加密算法之一。DES是对称性的，因为它使用同一个密钥来加密和解密数据。在当加密方加
密数据后同时又允许其解密的情况下，DES非常有用。DES还是一种分组加密算法，这就是说该算法每次都处理固定长度的数据段，称为分组。DES的分组大小为64位。
如果需要加密的数据总长度不是64的倍数，可以按照某种具体应用的方式填充位。

  

2015-02-02 18:59:09

DES被认为是相对安全的，而且运行速度很快，甚至在软件实现中都是这样。但是，同其他一些加密算法一样，DES的安全性从未得到公开的证明。不过，针对该算法已经有
过多年的安全性分析，这也为DES带来了一定程度的信心。尽管如此，随着计算机的运行速度持续提高，DES变得越来越脆弱。当今甚至有定期举办的挑战赛，来为那些能够
最快破解DES加密消息的人提供现金奖励。

  

  第16章 图算法

  

2015-02-02 19:02:13

最小生成树  
树可以看做许多相关联问题的抽象模型。最小生成树能用最小的代价将一个无方向的带权图的所有顶点连接起来。

  

2015-02-02 19:02:17

最短路径  
它是解决各类最短路径问题的结果。最短路径是连接一个有方向的带权图中两个顶点之间代价最小的路径。

  

2015-02-02 19:02:20

旅行商问题  
它是一个非常难以解决的问题，在此问题中，要寻找一条能够遍历一个完整且无方向的带权图中每个顶点（仅一次），并最终能够返回至起始顶点的路径。

  

  问与答

  

2015-02-02 19:13:51

问：在计算最小生成树与最短路径的实现中，带权图中边的权值都存储在图本身中。是否有什么方法可以替代这种做法？  
答：对于那些边的权值不经常变化的图，本章所使用的这种方法效果很好。然而，更为常用的做法是将边的权看做一个函数w（u,v），其中u和v就是权重函数要作用于的边
的两个顶点。为了确定一条边的权值，只需要调用此函数。这种方法的优点在于，在权值频繁变化的应用中能够动态地计算权值。另一方面，其缺点是，如果此权重函数比较复杂
，它可能会低效地进行重复计算。

  

  相关主题

  

2015-02-02 19:22:40

Bellman-Ford算法  
解决单源最短路径问题的另一种方法。与Kijkstra算法不同，Bellman-
Ford算法支持边权值为负的图。其时间复杂度为O（VE），其中V是图中顶点的个数，E为边的条数。

  

2015-02-02 19:22:47

Kruskal算法  
另一种计算最小生成树的算法。其算法原理如下。首先，将每个顶点放入其自身的数据集合中。然后，按照权值的升序来选择边。当选择每条边时，判断定义边的顶点是否在不同
的数据集中。如果是，将此边插入最小生成树的集合中，同时，将集合中包含每个顶点的联合体取出；如果不是，就移动到下一条边。重复这个过程直接所有的边都探查过。Kr
uskal算法的时间复杂度为O（ElgE）（假设用一个优先队列来管理边），其中E是图中边的数目。

  

  第17章 几何算法

  

2015-02-02 19:23:20

计算几何领域中的问题需要采用几何算法来解决。计算几何是数学领域中的一个分支，在计算几何中对点、线、多边形等此类几何相关的对象进行计算。在计算几何问题中有一个
很有趣的特点，那就是很多问题都有明显的视觉直观感。事实上，对于许多问题，只需要简单地通过观察它们的图形表示就能找到解决方案。比如，观察两条线段是否相交，这能
有多难？而另一方面，由于计算问题或多或少都要涉及一些算法，即使那些看似简单的问题（比如判断线段是否相交）都可能会很有挑战性。

  

2015-02-02 19:24:16

判断线段是否相交  
这可以通过一个简单的算法来完成。该算法有两个步骤：首先判断以两条线段为对角线的矩形是否相交，如果不相交，则两条线段肯定也不相交。然后判断这两条线段是否互相跨
越。如果两个检测结果都成立，那么说明这两条线段是相交的。

  

2015-02-02 19:25:15

凸包  
凸包是包含一个点集的最小凸多边形。如果一个多边形内任意两点之间的连线完全包含在该多边形内，则称这个多边形是凸多边形。

  

2015-02-02 19:25:19

球面弧长  
指球面上两点之间构成的弧线长度。具体来说，要计算出相同平面上从一点到另一点之间的弧线长度，这个平面由从球心画的虚线到球面上弧线两个端点的虚线确定。

* * *

多看笔记 来自多看阅读 for Kindle

duokanbookid:m9d7d2b6ggbb877097ede46d7793gd2d

