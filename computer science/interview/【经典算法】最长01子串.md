![](_resources/【经典算法】最长01子串image0.jpg)

### 最长01子串

#### 原题

给定一个数组，数组中只包含0和1。请找到一个最长的子序列，其中0和1的数量是相同的。  
例1：10101010 结果就是其本身。  
例2：1101000 结果是110100  
请大家展开自己的思路。

#### 分析

这个题目，看起来比较简单，一些同学可能认为题目的描述符合动态规划的特征，然后就开始用动态规划解，努力找状态转移方程。这些同学的感觉，是很正确的。但，找状态转
移方程，我们要对原来的数组进行变换一下。

原来是0和1的串，我们将0都换为-1。这样题目目标就变成，找到一个最长的子串，子串数字和是0。设原数组为A,
DP[i]表示从0开始到i的子数组和。DP遍历一遍数组即可。例1中的数组产生的DP为：

0

1

2

3

4

5

6

7

1

0

1

0

1

0

1

0

这个例子，最后一个值是0，并且长度是偶数位。直接满足了结果。

再看例子2：

0

1

2

3

4

5

6

1

2

1

2

1

0

-1

5的位置为0，最长子串从0开始到5，长度为6。

上面这两个例子，所求的子串都是从头开始，如果不是从头开始，会是什么样的呢？看这个例子：1101100

0

1

2

3

4

5

6

1

2

1

2

3

2

1

通过观察上面的表格，我们可以得到，DP[0]==DP[6]==DP[2]，DP[1]==DP[3]. 根据DP的定义，如果DP[i]==DP[j]，i
一种方法，我们用map保存DP的值到位置的映射，如下表：

DP值

位置

最大位置

最小位置

最大长度

1

0，2，6

6

0

6

2

1，3

3

1

2

3

4

4

4

0

最长子串长度

  

  

  

6

我们最终的算法，要综合考虑最常穿是否从头开始的。 上面的这个思路，时间复杂度是O(n),空间复杂度也是O(n).

还有其他的思路，例如DP保存的是[0,i]的1的个数，那么DP[j] - DP[i] * 2 == j -
i则表明A[i+1]...A[j]是一个满足条件的串，找到j-i最大的，就是最终的结果，这个思路的时间复杂度为O(n^2),空间复杂度为O(n).

【分析完毕】

阅读

__ 举报

[阅读原文](http://mp.weixin.qq.com/s?__biz=MjM5ODIzNDQ3Mw==&mid=200539538&idx=1&sn
=cd4e36f759fb22091e6ce86e51670fb5&scene=0#rd)

