## Objective-C编程

##### 【美】Aaron Hillegass

  

  2.6 不要半途而废

  

2014-07-10 09:46:01

Otto每天都会遇到几件让其困惑不解，倍感挫折的事情。Otto不停地吸收新知识，替换旧的固有思维。这类事情频繁发生，但Otto不会半途而废，停下来想“好难啊
，是不是应该把这本书扔掉？”  
随着年龄的增长，能难倒成年人的事情会少很多。不是因为成年人知道一切，而是因为成年人会选择避开那些自己不了解的事物。例如，阅读关于历史的书籍是轻松愉快的，因为
只需要借助现有的知识即可。这属于轻松类型的学习。

  

  12.4 id

  

2014-07-10 15:33:11

当声明指向对象的指针时，通常都会明确地写出相应对象的类：  
NSDate *expiration;  
但是在编写程序时，很可能会碰到以下这种情况：声明指针时并不知道所指对象的准确类型。为此，可以使用id类型。id的含义是：指针
，并可以指向任意类型的Objective-C对象。

  

2014-07-10 15:33:19

以下是一则使用示例：  
id delegate;  
注意，以上这则变量声明没有使用星号。id已经隐含了星号的作用。

  

  第24章　回调

  

2014-07-12 10:16:24

目标-动作（Target-action）：在应用开始等待前，要求“当x发生时，向指定的对象发送某个特定的消息”。这里接收消息的对象是目标（target），消
息的选择器（selector）是动作（action）。

  

2014-07-12 10:16:31

辅助对象（Helper objects）：在应用开始等待前，要求“当x发生时，向遵守相应协议的辅助对象发送消息”（第25章会对协议做更多的介绍）。委托对象（
delegate）和数据源（data source）是常见的辅助对象。

  

2014-07-12 10:16:37

通告（Notification）：Apple提供了一种称为通告中心（notification center）的对象。在应用开始等待前，可以告知通告中心“某个
对象正在等待某些特定的通告。当其中的某个通告出现时，向指定的对象发送特定的消息”。当x发生时，相关的对象会向通告中心发布通告，然后再由通告中心将通告转发给正
在等待该通告的对象。

  

  24.2 辅助对象

  

2014-07-13 08:00:14

目前的回调规则如下：当要向一个对象发送一个回调时，Apple会使用目标-动作对。当要向一个对象发送多个回调时，Apple会使用符合相应协议的辅助对象（第25
章会对协议做更多的介绍）。根据用途，辅助对象常称为委托对象（delegate）或数据源（data source）。

  

  24.4 如何选择

  

2014-07-13 08:04:38

本章已经介绍了三种类型的回调。Apple是如何根据情况在这些回调机制中做出选择的呢？  
对于只做一件事情的对象（例如NSTimer），使用目标-动作对。  
对于功能更复杂的对象（例如NSURLConnection），使用辅助对象。最常见的辅助对象类型是委托对象（delegate）。  
对于要触发多个（其他对象中的）回调的对象（例如NSTimeZone），使用通告。

  

  24.5 回调与对象所有权

  

2014-07-13 08:05:04

通告中心不拥有其下的观察器。如果将某个对象注册为观察器，那么通常应该在释放该对象时，将其移出通告中心

  

2014-07-13 08:05:20

对象不拥有其下的委托对象或数据源对象。如果某个新创建的对象是另一个对象的委托对象或数据源对象，那么该对象应该在其dealloc方法中取消相应的关联

  

2014-07-13 08:05:33

对象不拥有其目标。如果某个新创建的对象是另一个对象的目标，那么该对象应该在其dealloc方法中将相应的目标指针赋为0：

  

  第26章　Property List格式

  

2014-07-13 08:08:36

为了满足处理数据的需要，有时需要使用某种格式的文件。这类文件的格式需要满足以下条件：①可以由计算机读取。②人也可以阅读。例如，假设有某个程序，需要将股票投资
组合的描述信息保存在某个文件中。因为需要加入新的股票，所以这个文件最好可以很方便地进行手工编辑。此外，程序最好也能读取该文件。为了解决上述这类问题
，Objective-C程序员通常会使用属性列表（property list）格式。  
property list文件可以由以下对象组成：  
NSArray。  
NSDictionary。  
NSString。  
NSData。  
NSDate。  
NSNumber（整数、浮点数或布尔值）。

  

  27.5 Model-View-Controller

  

2014-07-13 08:19:42

模型负责保存数据，并能让其他对象访问这些数据。模型不处理用户界面，也无法将自己“画”在屏幕上。模型唯一需要完成的任务是保存并管理数据。Apple提供的NSS
tring对象、NSDate对象和NSArray对象都是模型对象。iTahDoodle中的模型对象目前只有NSMutableArray对象，用于保存任务信息
。稍后，程序会使用NSString实例来描述任务。届时，这些NSString对象也是模型对象。

  

2014-07-13 08:19:49

视图是应用中的可见元素，知道如何在屏幕上画出自己，并能响应用户输入。视图和其显示的数据没有直接的关联，也不负责其显示数据的保存和管理。UIView对象和众多
的UIView子类（例如UIWindow）对象都是常见的视图对象。iTahDoodle中的视图对象有UITableView实例、UITextView实例和U
IButton实例。要判断一个对象是否是视图对象，有一条简单的规则：能够看见的对象就是视图对象。

  

2014-07-13 08:19:54

控制器负责执行程序的逻辑功能，以连接和驱动应用的不同组成部分。控制器可以处理事件，并能与应用中的其他对象协同工作。应用中的控制器对象大都需要完成很多烦琐的任
务。虽然iTahDoodle只有一个控制器（BNRAppDelegate实例），但是复杂的应用会有很多不同的控制器，与模型对象、视图对象及其他控制器一起协同
工作。

  

  27.10 深入学习：main()的作用

  

2014-07-13 08:20:30

UIApplicationMain()函数会创建若干对象，使应用能够得以运行。首先，该函数会创建一个UIApplication类的实例（单实例）。接着，根据
传入的第四个实参（最后一个实参），创建相应的类实例并将其设置为应用的委托对象。该对象会收到各种应用委托消息，例如，内存过低警告、应用关闭或进入后台运行状态，
或应用启动完毕。

  

  30.1 属性的特性

  

2014-07-13 08:22:29

任何一个属性可以声明为readwrite或readonly，默认为readwrite。readwrite代表：程序应该自动创建存方法和取方法

  

2014-07-13 08:22:43

strong特性（第20章曾经用过）要求保留传入的对象，并放弃原有对象（如果原有对象不再有其他拥有方，就会被释放）。凡是指向对象的实例变量，通常都应该使用s
trong特性。

  

2014-07-13 08:22:55

weak特性要求不保留传入的对象。相应的存方法会将传入的对象直接赋给实例变量。如果该对象被释放，那么相应的实例变量会被自动赋为nil（如果在声明指针变量时，
使用的是unsafe_unretained特性，那么当其指向的对象被释放后，该指针将成为悬空指针。向悬空指针发送消息通常会导致程序崩溃）。

  

2014-07-13 08:23:00

copy特性要求拷贝传入的对象，并将新对象赋给实例变量。copy特性有一个细节问题很容易产生混淆。

  

  32.6 基于Block的编程是大势所趋

  

2014-07-13 08:25:07

学习Block对象并不容易，使用时也可能会遇到困难。但是，在开发由事件驱动的应用时（Mac和iOS中的程序大多属于这类），Block对象是非常有用的，且功能
强大。Apple提供的API已开始越来越多地使用Block对象。例如，ALAssetLibrary框架和GameKit框架就使用了大量基于Block对象的方
法。对Apple提供的API，建议读者尽可能多地使用基于Block对象的方法，这样既能提高效率，又能加强对Block对象的理解。

* * *

多看笔记 来自多看阅读 for Kindle

duokanbookid:e7c3f41c56294254ba516ca3fd4ba296

