  

Objective—C（以下简称OC）作为C语言的超集，其基本特性就是C语言可以直接在OC中无缝结合。随着开发时间越来越长，对C语言的熟悉往往给笔者带来很多
便利，所以这里一部分做个分析，一部分也是作为一些小经验的分享。新手写文，捉襟见肘，总结的不好，或是有更好的方法，还请诸位不吝指出。  
  
本文的示例代码以Command Line Tools的方式做了一个简单的demo，上传到了Github上，如果您感兴趣，也可以下载下来自己调试。  
  
**编程语言 **  
  
对于语言的定义多种多样，但是总让人觉得差强人意。所以笔者索性自己总结了下，为计算机语言归纳出了三个要素：  
  
**1.语素 **简单说来，语素就是符号与文字单元。从早起的二进制0和1，到汇编语言的汇编指令，到C语言的ASCII码字符集，再到swift的Unicode字符集。当然了，单纯的符号是无意义的，更为狭义的语素会经过语言语法的划分，如关键字、标识符、运算符、注释符等等。就定义而言，语素规范是由语法规定的，而就功能而言，语素明确了我们“用什么写”。   
  
**2.语法 **语法并不是某种显式的符号，而是编写或罗列语素的规则。从单个语素的含义，到语素间的排列规则，再到大段代码的执行顺序。语法负责让一整篇无意义的符号按照一定的规则表达出含义，我们可以将其称之为语义。一般来说，学语言初期，主要在学的就是语法了。就定义而言，语法是语义的表达框架，就功能而言，语法则明确了我们“如何去写”。   
  
**3.语义** 语义，可以归纳为思维的描述，引申的话，也可以归结为逻辑，毕竟逻辑就是思维的规律。无论是平常交流用的语言也好，与计算机交互使用的计算机语言也罢，究其本质，都是为了表达、沟通与理解。就定义而言，语义是语言使用者思维的具化体现，就功能而言，语义其实就是在表达“想写什么”。   
  
虽然从描述思维的角度来说，语义可以是无穷的，但无穷依旧有其局限性。这种局限性可以追溯到设计语言之初，从语言的特性与适用场所窥得端倪。

  

比如C语言中，选择ASCII字符集和其字符组合作为语素，用if(...)作为语法中的判断逻辑表达式，用if(x)return 1;来表达具体的语义。但当我们
希望描述一个变量拥有自己的函数时，就显得无比吃力。我们或许可以用很多句话来模拟，但是想要一句话解决问题就不可能了。究其原因，是因为C语言本身不支持这样的描述
方式。  
  
从层次上来说，支持什么样的描述方式往往是由语法来确定的，但究其原因，语法作为表达框架，其集合的边界是取决于我们语义的宽度的。其实说的简单点，只是因为设计语言
的时候，我们想说的东西还没有甚至没敢这么复杂。

  

深层次的语言设计初衷就不再探讨了，这些理由基本都囊括在自己的语言特性里，有人说想深学一门语言，就要学它的历史。从某个角度来说，这也是为了更方便我们去理解，设
计语言的人，想要用这个语言来表达什么而已。  
  
顺便讨论下日常语言和计算机语言的区别，对于日常语言和来说计算机语言，最大的区别在于受体。日常语言的表达对象是具有相似思维能力的活生生的人，语言从思维形成，到
表述，到传达，到接收时转化为自己所理解的信息，往往会进行多层次多维度的归纳和演绎。

  

计算机语言面对的是拥有着既定规则和一定计算能力的机器，所以需要我们的表达是精确到位的。所以，对应的语法也需要精确，“你不是一个人”这样的歧义句，放在日常语言
里或许只博得一笑，可放在计算机语言里，问题就严重了。  
  
语素、语法、语义作为语言的三要素，未必是最精确和科学的，不过对于计算机语言来说，这也算是一种归纳并定性的思路，可以让我们对一门语言有另一个层面的认识与特性区
分。不推荐强行的教条划分，顶多在自顶向下或是自底向上分析语言的时候，有个模型做借鉴吧。  
  
**声明、实现与调用 **  
  
说完了假大空的理论，我们回到C语言。 C语言定义了关键字、标识符、运算符、注释符这样的基本语素，定义了if、for等等的逻辑语句表达之后，最核心的元素分为两
种：数据与函数。对于C语言而言，代码的实际构成都可以归结为对数据和函数做以下三件事：声明、实现与调用。让我们从代码上来做一些简单的区分：

  

``

int var;//变量声明，格式为 “数据类型 标识符;"

int func(int);//函数声明，格式为“数据类型 标识符(数据类型,...);”

int func(int x){//函数实现，格式为“数据类型 标识符(数据类型 形参标识符,...){ ... return ...}”

var = x; //变量赋值，利用赋值运算符“=”

printf("%d",var); //变量调用，直接使用变量的标识符

return x?func(x-1):0;//函数调用，格式为“函数名标识符(传入参数)”

}

``

  
相信你看到上面这几句代码后面的拥挤的注释已经心慌慌了，不必紧张，这只是语法的一个列举。C语言语法自成一本书，笔者不会妄想到用一篇博客讲完的。如果你有一定的C
语言开发经验，你就会发现上面这段代码写的毫无意义，也就最后一句的递归调用可以装装逼。  
  
首先，函数有一个很特别的地方，那就是它的调用，比如func()。这样的表达是被视作一个数据来占位的，在实际含义中表示它的返回值。这个特性将函数与数据从语法上
放在了平行的位置，虽然看着不起眼，但这是个很棒的特性。让我们可以用同样的方式去对待计算过程和一个具体的值。 我们可以以此做两种假设：  
  
把变量当做函数：变量取值本身也是个过程，我们调用一个变量，其实也是通过一定过程取得了一个返回值。 int i = 1;与int i(){return
1;}在功能上是否很相似呢？  
  
把函数当做变量：任何一个函数在调用后一定对应着一个确定的返回值，哪怕是一个void类型，也是与数据类型所对应的。所以哪怕是func(func(func(fu
nc(1))))，最终依旧是个int型的数据而已。  
  
当然了，从实现角度来说，变量与函数的差别很大。但在编写代码的时候，尤其是将函数当做一个变量，会减少我们所需要关注的地方。我们完全可以声明一个int
whoCare(int,int),当做一个变量调用。最后再去考虑它的实现过程。  
  
当我们把函数的调用视作一个数据占位符的时候，我们会发现整个语法变得简单了不少。除了声明和实现的格式，语句就剩下各种情况下的数据运算了，然后嵌套，调用，随意重
复n++次。  
  
那么回到我们的声明和实现，整个语法格式其实是走一步算一步的。  
  
![](%E8%AF%AD%E6%B3%95%E6%B5%85%E6%9E%90--%E4%BB%8EC%E8%AF%AD%E8%A8%80%E5%88%B
0Objective-C.resources/image0.png)  
  
大概就是上图这个样子了。语法是个坑，一边学一边用成长起来比较快。大部分实践经验证明，学语法基本都是从写什么不可以开始的，找个报错功能靠谱，比如Xcode这样
的IDE软件开始码代码吧，什么时候静态编译不报错了，语法关也就过的差不多了。  
  
**OOP的OC **  
  
语言设计从来不是一件轻松的事情，每一个规则的设计都取舍于性能和易用性，一方面要求严谨，一方面要求灵活。从C语言中发展出来的面向对象语言就有好几种，它们唯一的
共同特征大概就是都可以直接运行C语言代码了（笑= =）。  
  
从个人情感角度来说，笔者对于OC的这门语言的热爱大概只有Python能够分一杯羹了。无关于性能、环境与语法，其钟爱点仅仅源于方括号[]，让整篇代码看起来整齐
美观。  
  
为了拓展面向对象的功能，一方面，OC在C语言中采纳了很多固有特性来模拟对象特性。另一方面，则另起炉灶，设计了另外一套关键字语法系统，而且设计的颇具美感。第一
眼看上去，语法或许特殊到再也见不到类似的，但是细细揣摩上去，反倒是因为这种不同让我们在同一个片段里混用C语言语法与OC语法，也绝对不会混淆。  
  
理论上，这里是应该对比一下C++的，不过笔者对C++学习甚浅，还是不要妄加论断的好。这里要说的是，OC也加入了与C++混编的功能，不过因为对象机制不同，不同
语言下的面向对象语法是不能相互替换的。一想到一篇代码里会存在两种类，一个对象= new CPPClass,一个= [OCClass new],望而生畏。  
  
OC语法区别于C语言的主要地方都是在对象层面，对于基础的语法，基本上可以照抄照搬，倒也省心省事。  
  
所以从基本语素说起，我们就可以直接看OC的对象与方法了。顺便提一句OC的文件结构。在C语言里面，.c文件是靠#include来声明包含的，在OC里面，则会分
为.h和.m文件。

  

如果你像我一样对引用生出好奇心的话，会发现是没有对.m的引用的，但是文件里的实现代码却会被执行，答案很简单，编译器用另外一种方式替我们做了这件事。至于具体如
何做到，这里先不讨论（笔者也顺便再研究研究= =）。要说明的是，尽可能不要在OC中写#import "....m"，即便这样是完全可以的。  
  
第一步，我们来建立一个新的对象好了。为了方便，我稍稍违反一下默认的文件结构，将声明和实现代码都搬到一个.h文件里，请不要在写代码的时候这样做。  
  

//BCObject.h

@import Foundation;

#pragma mark - BCObject.h

@interface BCObject : NSObject

@end

#pragma mark - BCObject.m

@implementation BCObject

@end

  
与C语言的声明与实现相对应，在OC中，一个类也需要做这两件事，并且赋予了专门的关键字。在这里叫关键字或许不太合适，你也可以称为编译器标记，毕竟从实现角度来说
，它们和之前的关键字的功能还不太一样。在OC中，@符号的功能颇多，在这里，是与后面定义好的字符共同作为一个标记出现，供编译器进行转义。比如@import是库
引用，@interface是类声明，而@implementation则是类实现，当然了，声明和实现还需要伴随@end这样的结束记号。  

  

OC的面向对象语法基本都是在自己的编译器标记中才可以使用的，它等于和编译器约定，在@...@end之间的代码，是使用OC编写的。也可以反过来做假设，如果不在
声明和实现的段落中，则该语句与对象无关，那么面向对象的语法也就想当然的无法成立了。
不过，这只是针对声明和实现，如果仅仅是调用，OC和C语法的混搭，真的是爽歪歪~

  

@implementation BCObject

+(NSString *)hello{

return @"hello world";

}

@end

void say(NSString *str){

NSLog(@"%@",str);

}

  
然后，我们就可以使用say([BCObject hello]);这样的语句来实现"hello world"了。  
  
如果你仔细观察，你会发现我并没有为+(NSString *)hello这个方法做声明，只是和C语言中一样，把实现放在了调用的代码段前。  

  

这里也顺便说明一个问题，在面向对象中，往往会有私有方法和实例变量这样的说法。在OC中，最简单的方法是把私有的东西放在.m方法里，因为不存在文件包含，所以也就
无法调用了。

  

而像我们刚才这样，直接调用@implenmentation的方法，就会发现他是没有语法上的防御力的，仅仅是靠文件结构的约定俗成而已。这也是为什么不让大家引用
.m文件的原因之一。  
  
不过，如果是私有实例变量的话，OC却是提供了对应的标记来声明私有。

  

@import Foundation;

@interface BCObject : NSObject{

@public

NSString *hello;

@private

NSString *bye;

}

@end

@implementation BCObject

-(instancetype)init{

self = [super init];

if(self){

hello = @"hello";

bye = @"bye";

}

return self;

}

-(NSString *)bye{

return bye;

}

@end

//在main.m中调用

int main(int argc, const char * argv[]) {

@autoreleasepool {

say([BCObject hello]);

BCObject *obj = [BCObject new];

say(obj -> hello);

say(obj.bye);

return 0;

}

}

  
在C语言中，我们可以用->来寻址结构体指针中的元素数据，而在OC中，我们则可以通过这个符号来寻址对象内的实例变量。有没有联想到什么呢？对=
=因为OC的对象的其实就是个结构体指针，这个运算是通用的。只不过，我们可以通过@private和@public，当然也会有@protect来限制访问权限。  
  
不过，在实际编写中，这样的声明和取值实在太过繁琐，虽然可以这么用，但早已鲜有人问津。自OC2.0之后，我们有了@property用来解决类内实例变量对外的存
取，我们将其翻译为属性，并形象的将它的存取方法称为setter和getter。在这之后，访问类内的实例变量就全部靠方法，而非指针了。

  

@interface BCObject : NSObject{

@public

NSString *hello;

@private

NSString *bye;

}

@property NSString *word;

@end

//在main.m中调用

int main(int argc, const char * argv[]) {

@autoreleasepool {

say([BCObject hello]);

BCObject *obj = [BCObject new];

obj.word = obj -> hello;

say(obj.word);

return 0;

}

}

  
回过头来看OC的声明和实现语法，数据的声明和c语言完全一样，只不过对象都是指针，所以总会多个"*"号。而在方法的声明和实现中，为了区别于C语言的函数，OC使
用“()”来声明数据类型，使用“:”来标识传入参数，并且创新的引入了参杂多个“:”的函数命名方式，让整个句子看着更符合语言逻辑。  

  

虽然这个特性对我等英语盲人来说意义并不大，但是[you doItWith:A and:B
for:C]看起来比you.doIt(A,B,C)还是要舒服的多了。如果英语词汇量充足的话，我们是可以有效的减少翻阅文档的次数的。  
  
因为格式特立独行，所以想要混淆就变的困难。OC的语法看起来唬人，学起来倒也不算难，还是那句话，在xcode里多写代码，什么时候静态编译不报错了，语法自然就过
关了。  
  
**多说一点 **  
  
除了声明、实现、调用的格式之外，语法需要学习的地方还有很多。  
  
在C语言中，我们要考虑变量的作用域，参数的值传递与引用传递，要考虑一个值的储存方式等等。  
  
在OC中，复杂的东西则更多，不过，随着学习的递进，我们就会发现这些东西其实不在语法范畴之内，比如模式，比如库和框架，比如内存管理，再比如Runtime机制。  
  
如果你已经有编程基础的话，那么玩转一门新语言的语法并不是一件非常困难的事。  
  
学语法，或许一周左右。  
  
学习语言特性，或许把玩个把月也就很有成效了。  
  
不过学语言真正困难的地方在于语言的环境：框架、适应场合、需要解决的问题、持续的更新与升级还有使用群体的约定俗成。如果非让我加个期限的话，那会是，一万年。  
  
**总结与吐槽 **  
  
对于一个初学者来说，学习语法往往是个很别扭的事情。因为大量的符号、关键字和标记需要逐个去记忆，而且还需要分门别类的明确这些符号分别是做什么用的。

  

尤其是对于一个英语盲来说，将int、long、short、float、double、char、void归为一类比独立背下来这些单词还要再难上一分。而好不容易
过了词汇关的我们，接下来面对的示例代码，全都是些陌生的单词，根本不知道在说什么好不好。

  

记起来当初大神们为特性举例子总喜欢拿几个系统内置的生僻方法来举例，语法理解不了不说，还要特地先去查这些方法是什么，否则返回值根本莫名其妙啊= =。  
  
正因为这样的事情总是发生，所以总结一些语法特征，可以多多少少帮我们点忙。比如()是函数，[]是方法，{}是一大句话，标识符都是大神们戏谑我们特地起的人名地名
（吐槽...吐槽= =）。阅读理解逼着我们挨个看单词，可读源代码，是可以先读符号的。这也是语法给我们带来的一点小便利。

  

（来自bifidy的投稿）

  

喜欢我们的内容，可以点击右上角**「分享到朋友圈」**，或**「查看官方账号」**并关注我们。

阅读原文

阅读

__ 举报

[阅读原文](http://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&mid=201778334&idx=4&sn
=f7889fe8385d05386d19d64e260cce7e&scene=0#rd)

