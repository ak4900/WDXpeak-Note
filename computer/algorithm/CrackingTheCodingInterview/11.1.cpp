#include <iostream>
using namespace std;

void merge(int a[], int b[], int n, int m){
    int k = n + m - 1;
    int i = n - 1, j = m - 1;
    while(i>=0 && j>=0){
        if(a[i] > b[j]) a[k--] = a[i--];
        else a[k--] = b[j--];
    }
    while(j>=0) a[k--] = b[j--];
}

int main(){
    int a[15] = {
        1, 3, 7, 8, 9
    };
    int b[] = {
        2, 4, 5, 6, 10
    };
    int n = 5, m = 5;
    merge(a, b, 5, 5);
    for(int i=0; i<m+n; ++i)
        cout<<a[i]<<" ";
    return 0;
}

/*
让我们再加点限制条件，如果两个有序的序列并且没有额外的空间，那要怎么排序。 比如对于数组A，它的前半段和后半段分别有序，不使用额外的空间怎么使A整体有序。

首先，不可避免的我们还是要将两个有序部分中的元素拿出来对比。 我们先拿出前半段的第一个元素和后半段的第一个元素进行对比， 如果后半段的第一个元素要小，就将它们交换。由于这两个元素是各自序列的最小值， 这一对比就将整个数组A的最小值取出放在了正确的位置上。然后呢？ 交换到后半段的那个值怎么办？不理它，不太合适吧。我们可以通过两两对比， 把它移动到后半段的某个位置，使后半段保持有序。接下来呢？ 我们取出前半段的第2个元素(第1个元素已经放在它正确的位置上，不用理它了)， 还是和后半段的第1个元素对比，这一对比中较小的就会是整个数组中第2小的元素， 如果是后半段那个元素较小，则交换它们，然后仍然移动后半段使其保持有序。 这样不断进行下去，当把前半段的元素都遍历操作一遍，就会将小的元素都移动到前半段， 并且是有序的。而大的元素都在后半段且也是有序的。排序结束。
*/

void swap(int &a, int &b){
    a = a^b;
    b = a^b;
    a = a^b;
}
void merge(int a[], int begin, int mid , int end){
    for(int i=begin; i<=mid; ++i){
        if(a[i]>a[mid+1]){
            swap(a[i], a[mid+1]);
            for(int j=mid+1; j<end; ++j){
                if(a[j]<=a[j+1]) break;
                swap(a[j], a[j+1]);
            }
        }
    }
}
int main(){
    int a[10] = {
        8, 9, 11, 15, 17, 1, 3, 5, 12, 18
    };
    int b[10] = {
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10
    };
    merge(a, 0, 4, 9);
    for(int i=0; i<10; ++i)
        cout<<a[i]<<" ";
    return 0;
}