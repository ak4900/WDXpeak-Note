# Computer Systems : A Programmer's Perspective
# 深入理解计算机系统
_Notes from Da Wang, Feb.2 2015_

<!-- MarkdownTOC -->

- 前言
	- 第 1 章：计算机系统漫游
		- 1.1 信息就是位 + 上下文
		- 1.2 程序被其他程序翻译成不同的格式
		- 1.3 了解编译系统如何工作是大有益处的
		- 1.4 处理器读并解释存储在存储器中的指令
			- 1.4.1 系统的硬件组成
			- 1.4.2 运行 hello 程序
		- 1.5 高速缓存至关重要
		- 1.6 存储设备形成层次结构
		- 1.7 操作系统管理硬件
			- 1.7.1 进程
			- 1.7.2 线程
			- 1.7.3 虚拟存储器
			- 1.7.4 文件
		- 1.8 系统之间利用网络通信
		- 1.9 重要主题
			- 1.9.1 并发和并行
			- 1.9.2 计算机系统中抽象的重要性
- 第一部分：程序结构和执行
	- 第 2 章：信息的表示和处理
		- 2.1 信息存储
			- 2.1.1 十六进制表示法
			- 2.1.2 字
			- 2.1.3 数据大小
			- 2.1.4 寻址和字节顺序
			- 2.1.5 表示字符串
			- 2.1.6 表示代码
			- 2.1.7 布尔代数简介
			- 2.1.8 C 语言中的位级运算
			- 2.1.9 C 语言中的逻辑运算
			- 2.1.10 C 语言中的移位运算
		- 2.2 整数表示
			- 2.2.1 整型数据类型
			- 2.2.2 无符号数的编码
			- 2.2.3 补码(two's-complement)编码
			- 2.2.4 有符号数和无符号数之间的转换
			- 2.2.5 C 语言中的有符号数与无符号数
			- 2.2.6 扩展一个数字的位表示
			- 2.2.7 截断数字
			- 2.2.8 关于有符号树与无符号数的建议
		- 2.3 整数运算
			- 2.3.1 无符号加法
			- 2.3.2 补码加法
			- 2.3.3 补码的非
			- 2.3.4 无符号乘法
			- 2.3.5 补码乘法
			- 2.3.6 乘以常数
			- 2.3.7 除以 2 的幂
			- 2.3.8 关于整数运算的最后思考
		- 2.4 浮点数
			- 2.4.1 二进制小数
			- 2.4.2 IEEE 浮点表示
			- 2.4.3 数字示例
			- 2.4.4 舍入(rounding)
			- 2.4.5 浮点运算
			- 2.4.6 C 语言中的浮点数
		- 2.5 小结
	- 第 3 章：程序的机器级表示
		- 3.1 历史观点
		- 3.2 程序编码
			- 3.2.1 机器级代码
			- 3.2.2 代码示例
			- 3.2.3 关于格式的注释
			- 3.2.4 数据格式
		- 3.4 访问信息
			- 3.4.1 操作数指示符
			- 3.4.2 数据传送指令
		- 3.5 算术和逻辑操作
			- 3.5.1 加载有效地址
			- 3.5.2 一元操作和二元操作
			- 3.5.3 移位操作
			- 3.5.4 讨论
			- 3.5.5 特殊的算术操作
		- 3.6 控制
			- 3.6.1 条件码
			- 3.6.2 访问条件码
			- 3.6.3 跳转指令及其编码
			- 3.6.4 翻译条件分支
			- 3.6.5 循环
			- 3.6.6 条件传送指令
			- 3.6.7 switch 语句
		- 3.7 过程
			- 3.7.1 栈帧结构
			- 3.7.2 转移控制
			- 3.7.3 寄存器使用惯例
			- 3.7.4 过程示例
			- 3.7.5 递归过程
		- 3.8 数组分配和访问
			- 3.8.1 基本原则
			- 3.8.2 指针运算
			- 3.8.3 嵌套的数组
			- 3.8.4 定长数组
			- 3.8.5 变长数组
		- 3.9 异质的数据结构
			- 3.9.1 结构
			- 3.9.2 联合
			- 3.9.3 数据对齐
		- 3.10 综合：理解指针
		- 3.11 应用：使用 GDB 调试器
		- 3.12 存储器的越界引用和缓冲区溢出
		- 3.13 x86-64: 将 IA32 扩展到 64 位
		- 3.14 浮点程序的机器级表示
		- 3.15 小结
	- 第 4 章：处理器体系结构
		- 4.1 Y86 指令集体系结构
			- 4.1.1 程序员可见的状态
			- 4.1.2 Y86 指令
			- 4.1.3 指令编码
		- 4.2 逻辑设计和硬件控制语言 HCL
			- 4.2.1 逻辑门
			- 4.2.2 组合电路和 HCL 布尔表达式
			- 4.2.3 字级的组合电路和 HCL 整数表达式
		- 4.3 Y86 的顺序实现
		- 4.4 流水线的通用原理
		- 4.5 Y86 的流水线实现
		- 4.6 小结
	- 第 5 章：优化程序性能

<!-- /MarkdownTOC -->


# 前言

从程序员的角度来学习计算机系统是如何工作的会非常有趣，主要是因为你可以主动地来做这件事情。无论何时你学到一些新的东西，都可以马上试验并且直接看到运行结果。事实上，我们相信学习系统的唯一方法就是做(do)系统，即再真正的系统上解决具体的问题，或是编写和运行程序。

本书起源于1998年秋季，作者在 CMU 开设的编号为15-213的介绍性课程：计算机系统导论(Introduction to Computer Systems, ICS)，是大多数高级系统课程的先行必修课。宗旨是用一种不同的方式向学生介绍计算机，只讨论那些影响用户级 C 语言程序的性能、正确性或实用性的主题。


## 第 1 章：计算机系统漫游

我们通过跟踪 helloworld 程序的生命周期来开始对系统的学习——从它被程序员创建，到在系统上运行，输出简单的消息，然后终止。

### 1.1 信息就是位 + 上下文

![csapp1.1](./_resource/csapp1.1.jpg)

hello.c 程序以字节序列的方式存储在文件中。每个字节都有一个整数值，而该整数值对应于某个字符。

![csapp1.2](./_resource/csapp1.2.jpg)

hello.c 的表示方法说明了一个基本的思想：系统中所有的信息——包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传送的数据，都是由一串位表示的。区分不同数据对象的唯一方式是我们读到这些数据对象时的上下文。

**C 编程语言的起源**

+ 贝尔实验室的 Dennis Ritchie 于 1969-1973 年创建
+ C 语言与 Unix 操作系统关系密切
+ C 语言小而简单
+ C 语言是为实践目的而设计的
+ C 语言是系统级编程的首选，同时它也非常适用于应用级程序的编写。然而，它也并非适用于所有的程序员和所有的情况。C 语言的指针是造成困惑和程序错误的一个常见原因。同时，C 语言还缺乏对非常有用的抽象（类、对象和异常）的显式支持。

### 1.2 程序被其他程序翻译成不同的格式

hello 程序的生命周期是从一个高级 C 语言程序开始的，因为这种形式能够被人读懂。为了在系统上运行，每条 C 语句都必须被其他程序转化为一系列的低级**机器语言**指令。然后这些指令按照一种称为**可执行目标程序**的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为**可执行目标文件**。

在 Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：

	unix> gcc -o hello hello.c

这个翻译过程可分为四个阶段。这行这四个阶段的程序（预处理器cpp、编译器ccl、汇编器as和链接器ld）一起构成了编译系统（compilation system）。

![csapp1.3](./_resource/csapp1.3.jpg)

**GNU 项目**

GCC 是 GNU(GNU's Not Unix) 项目开发出来的众多有用工具之一。GNU 项目已经开发出了一个包含 Unix 操作系统的所有主要部件的环境，但内核除外，内核是由 Linux 项目独立发展而来的。GNU 环境包括 EMACS 编辑器、GCC 编译器、GDB 调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。

### 1.3 了解编译系统如何工作是大有益处的

知道编译系统是如何工作非常重要，原因如下：

+ **优化程序性能**。了解一些机器代码以及编译器将不同的 C 语句转换为机器代码的方式。
	+ 一个 switch 语句是否总是比一系列 if-else 语句高效得多？
	+ 一个函数调用的开销有多大？
	+ while 循环比 for 循环更有效吗？
	+ 指针引用比数组索引更有效吗？
+ **理解链接时出现的错误**。一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。
	+ 无法解析一个引用是什么意思？
	+ 静态变量和全局变量的区别是什么？
	+ 在不同 C 文件中定义的名字相同的两个全局变量会发生什么？
	+ 静态库和动态库的区别是什么？
	+ 我们在命令行上排列库的顺序有什么影响？
+ **避免安全漏洞**。学习安全变成的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。

### 1.4 处理器读并解释存储在存储器中的指令

要想在 Unix 系统上运行可执行目标文件 hello，将文件名输入到 shell 中：

	unix> ./hello
	hello, world
	unix>

shell 是一个命令行解释器，它输出一个提示符，等待你输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 shell 命令，那么 shell 就会假设这是一个可执行文件的名字，它将加载并运行这个文件。

#### 1.4.1 系统的硬件组成

下图是 Intel Pentium 系统产品系列的模型：

![csapp1.4](./_resource/csapp1.4.jpg)

1. **总线**：贯穿整个系统的电子管道，携带信息字节并负责在各个部件间传递。通常总线呗设计成传送定长的字节块，也就是字(word)。假设字长为 4 个字节，并且总线每次只传送 1 个字。
2. **I/O 设备**：系统与外部世界的联系通道。每个 I/O 设备都通过一个**控制器**或**适配器**与 I/O 总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是置于 I/O 设备本身的或者系统的主板上的芯片组，而适配器则是一块插在主板插槽上的卡。
3. **主存**：临时存储设备，由一组动态随机存取存储器(DRAM)芯片组成。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一地址。
4. **处理器**：解释(或执行)存储在主存中指令的引擎。核心是一个字长的存储设备(或寄存器)，称为程序计数器(PC)。在任何时刻，PC 都指向主存中的某条机器语言指令。从系统痛点开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，在更新程序计数器，使其指向下一条指令。

#### 1.4.2 运行 hello 程序

当我们输入“./hello”后，shell 程序将字符逐一读入寄存器，再把它存放到存储器中，如下图所示：

![csapp1.5](./_resource/csapp1.5.jpg)

利用直接存储器存取(DMA)技术，数据可以不通过处理器而直接从磁盘到达主存

![csapp1.6](./_resource/csapp1.6.jpg)

一旦目标文件中的代码和数据被加载到主存，处理器就开始执行 hello 程序的 main 程序中的机器语言指令。这些指令将“hello, world\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。

![csapp1.7](./_resource/csapp1.7.jpg)

### 1.5 高速缓存至关重要

这个简单的例子揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。因此，系统设计者的一个主要目的就是使这些复制操作尽可能快地完成。

![csapp1.8](./_resource/csapp1.8.jpg)

较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。针对这种差异，系统设计者采用了更小、更快的存储设备，即**高速缓存存储器**，作为暂时的集结区域，用一种叫**做静态随机访问存储器(SRAM)**的硬件技术实现。

### 1.6 存储设备形成层次结构

从上至下，设备的访问速度越来越慢、容量越来越大，每字节的造价也越来越便宜。

![csapp1.9](./_resource/csapp1.9.jpg)

### 1.7 操作系统管理硬件

我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。操作系统有两个基本功能：

1. 防止硬件被失控的应用程序滥用。
2. 向应用程序提供简单一致的机制来控制复杂而又通常大相径庭的低级硬件设备。

![csapp1.10](./_resource/csapp1.10.jpg)

操作系统通过几个基本的抽象概念(进程、虚拟存储器和文件)来实现这两个功能。

**Unix 和 Posix**

20 世纪 60 年代是大型、复杂操作系统盛行的年代，如 IBM 的 OS/360 和 Honeywell 的 Multics 系统。贝尔实验室曾经是 Multics 项目的最初参与者，但是因为项目复杂和缺乏进展于 1969 年退出。这之后一组贝尔实验室的研究人员(Ken Thompson, Dennis Ritchie, Doug Mcllroy & Joe Ossanna)从1969年开始在 DEC PDP-7 计算机上完全用机器语言编写了一个简单得多的系统，1970 年 Brian Kernighan 命名为“Unix”。1973 年用 C 语言重新编写内核，1974年开始对外发布。

发布之后不同的 Unix 厂商加入新的、往往不兼容的特性来使它们的程序与众不同，也带来很多麻烦，为了阻止这种趋势，IEEE 开始努力标准化 Unix 的开发，后来由 Richard Stallman 命名为“Posix”，称为 Posix 标准。

#### 1.7.1 进程

**进程**是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。无论是在单核还是多核系统中，一个 CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的，这种交错执行的机制称为**上下文切换**。

操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是**上下文**，它包括许多信息，例如 PC 和寄存器文件的当前值，以及主存的内容。

![csapp1.12](./_resource/csapp1.12.jpg)

#### 1.7.2 线程

一个进程实际上可以由多个称为**线程**的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器对并行处理的需求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，一般来说也更高效。

#### 1.7.3 虚拟存储器

**虚拟存储器**是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的是一致的存储器，称为**虚拟地址空间**。

在 Linux 中，地址空间最上面的区域是为操作系统中的代码和数据保留的，这对所有进程来说都是一样的。地址空间的底部区域存放用户进程定义的代码和数据，请注意，图中的地址是从下往上增大的。

![csapp1.13](./_resource/csapp1.13.jpg)

从最低的地址开始，逐步向上介绍：

+ **程序代码和数据**。对于所有的进程来说，代码是从同一固定地址开始，紧接着是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。
+ **堆**。代码和数据区后紧随着的是运行时堆。代码和数据区是在进程一开始运行就被规定了大小，与此不同，当调用如 malloc 和 free 这样的 C 标准库函数时，对可以在运行时动态地扩展和收缩。
+ **共享库**。大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。
+ **栈**。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。
+ **内核虚拟存储器**。内核总是主流在内存中，是操作系统的一部分。地址空间顶部的区域是为内核保留的，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。

#### 1.7.4 文件

**文件**就是字节序列，仅此而已。这个简单而精致的概念拥有极其丰富的内涵，它向应用程序提供了一个统一的视角，来看待系统中可能含有的所有 I/O 设备。

![csapp0.1](./_resource/csapp0.1.jpg)

### 1.8 系统之间利用网络通信

从一个单独的系统来看，网络可视为一个 I/O 设备。当系统从主存将一串字节复制到网络适配器时，数据流经过网络到达另一台机器，而不是其他地方。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。

![csapp1.14](./_resource/csapp1.14.jpg)

### 1.9 重要主题

系统不仅仅只是硬件，而是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的。下面是几个贯穿计算机系统所有方面的重要概念：

#### 1.9.1 并发和并行

**并发(concurrency)**是一个通用的概念，指一个同时具有多个活动的系统；**并行(parallelism)**指的是用并发使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。

**1.线程级并发**

传统意义上，这种并发执行只是模拟出来的，是通过正在执行的进程间快速切换的方式实现的，这种配置称为**单处理器系统**。

![csapp1.16](./_resource/csapp1.16.jpg)

当构建一个由单操作系统内核控制的多处理器组成的系统时，就得到了一个**多处理器系统**。超线程，有时称为**同时多线程(simultaneous multi-threading)**，是一项允许一个 CPU 执行多个控制流的技术。

![csapp1.17](./_resource/csapp1.17.jpg)

多处理器的使用可以从两个方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。其次，它可以使应用程序运行得更快。

**2.指令级并行**

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为**指令级并行**。流水线(pipelining)的引入使得指令并行成为可能。如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为**超标量(superscalar)**处理器。

**3.单指令、多数据并行**

在最低层次上，许多处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，即 SIMD 并行。

#### 1.9.2 计算机系统中抽象的重要性

**抽象**的使用是计算机科学中最为重要的概念之一。

![csapp1.18](./_resource/csapp1.18.jpg)

在处理器里，**指令集结构**提供了对实际处理器硬件的抽象。在操作系统中：**文件**是对 I/O 的抽象，**虚拟存储器**是对程序存储器的抽象，而**进程**是对一个正在运行的程序的抽象。虚拟机则是对整个计算机(包括操作系统、处理器和程序)的抽象。

# 第一部分：程序结构和执行

计算机由处理器和存储器子系统组成。在核心部分，我们需要方法来表示基本数据类型，比如整数和实数运算的近似值。然后，我们考虑机器级指令如何操作这样的数据，以及编译器如何将 C 程序翻译成这样的指令。这一部分将帮助你深入了解如何表示和执行应用程序。

## 第 2 章：信息的表示和处理

单个 bit 不是非常有用，然而，当把 bit 组合在一起，再加上某种解释(interpretation)，即给不同的可能位模式赋予含义，就能够表示任何有限集合的元素。计算机的表示法适用有限数量的 bit 来对一个数字编码，因此，当结果太大以至于不能表示时，某些运算就会**溢出(overflow)**。

浮点运算有完全不同的数学属性，由于精度有限，浮点运算是不可结合的。整数的表示虽然只能编码一个相对较小的数值范围，但这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但这种表示只是近似的。

**C 编程语言的演变**

C -> ANSI C -> ISO C90 -> ISO C99

GNU 编译器套装(GNU Compiler Collection, GCC)可以基于不同的命令行选项，依照多个不同版本的 C 语言规则来编译程序。

![csapp2.1](./_resource/csapp2.1.jpg)

### 2.1 信息存储

大多数计算机使用8位的块，或者 byte 作为最小的可寻址的存储器单位，而不是在存储器中访问单独的 bit。机器级程序将存储器视为一个非常大的字节数组，称为**虚拟存储器(virtual memory)**。存储器的每个字节都由一个唯一的数字来标识，称为它的**地址(address)**，所有可能的地址集合称为**虚拟地址空间(virtual address space)**。

#### 2.1.1 十六进制表示法

一个 byte 由 8 个 bit 组成。在二进制表示法中，它的值域是 00000000(2) ~ 11111111(2)；如果用十进制整数表示，它的值域就是 0 ~ 255。用十六进制书写，一个字节的值域为 00(16) ~ FF(16)。

![csapp2.2](./_resource/csapp2.2.jpg)

#### 2.1.2 字

每台计算机都有一个**字长(word size)**，指明整数和指针数据的**标称大小(nominal size)**。因为虚拟地址是以这样一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长尾 w 位的机器而言，虚拟地址的范围为 0 ~ 2^(w-1)，程序最多访问 2^w 个字节。现在的 32 位机器指的就是字长是 32 位，就限定了虚拟地址空间为 4GB。

#### 2.1.3 数据大小

计算机和编译器支持多种不同方式编码的数字格式，如整数和浮点数，以及其他长度的数字。

![csapp2.3](./_resource/csapp2.3.jpg)

程序员应该力图使他们的程序在不同的机器和编译器上是可移植的。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。

#### 2.1.4 寻址和字节顺序

对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在存储器中如何排列这些字节。

某些机器选择在存储器中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则——最低有效字节在最前面的方式，称为**小端法(little endian)**。后一种规则——最高有效字节在最前面的方式，称为**大端法(big endian)**。许多比较新的微处理器使用**双端法(bi-edian)**，也就是说可以把它们配置成作为大端或者小端的机器运行。

几种机器所使用的字节顺序会成为问题的情况：

1. 在不同类型的机器之间通过网络传送二进制数据。
2. 当阅读表示整数数据的字节序列时，字节顺序也很重要。
3. 当编写规避正常的类型的系统时。

**使用 typedef 命名数据类型**

C 语言中的 typedef 声明提供了一种给数据类型命名的方式。这能够极大地改善代码的可读性，因为深度嵌套的类型声明很难读懂。typedef 的语法与声明变量的语法十分相似，除了它使用的是类型名，而不是变量名。

#### 2.1.5 表示字符串

C 语言中字符串被编码为一个以 null(其值为 0)字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是 ASCII 字符码。在使用 ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关，因此文本数据比二进制数据具有更强的平台独立性。

![csapp0.2](./_resource/csapp0.2.jpg)

#### 2.1.6 表示代码

考虑下面的 C 函数：

	int sum(int x, int y) {
		return x + y;
	}

当我们在示例机器上编译时，生成如下字节表示的机器代码：

![csapp0.3](./_resource/csapp0.3.jpg)

可以看到指令编码是不同的。不同的机器类型使用不同的且不兼容的指令和编码方式。因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。

#### 2.1.7 布尔代数简介

二进制是计算机编码、存储和操作信息的核心，所以围绕 0 和 1 的研究演化出了丰富的数学知识体系。

![csapp2.7](./_resource/csapp2.7.jpg)

#### 2.1.8 C 语言中的位级运算

C 语言支持按位布尔运算，确定一个位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制并执行二进制运算，然后转换回十六进制。

位级运算的一个常见用法就是实现**掩码**运算，这里的掩码是一个位模式，表示从一个字中选出的位的集合。

#### 2.1.9 C 语言中的逻辑运算

C 语言还提供了一组逻辑运算符 ||、&& 和 !，分别对应于命题逻辑中的 OR、AND 和 NOT 运算。

#### 2.1.10 C 语言中的移位运算

C 语言还提供了一组移位运算，以便向左或者向右移动位模式：<<、>>。

x << k 会生成一个值，x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个 0。

右移 x >> k 比较微妙，一般而言，机器支持两种形式的右移：逻辑右移(补 0)和算术右移(补 1)。对于无符号数据，右移必须是逻辑的。对于有符号数据，几乎所有的编译器 / 机器组合都使用算术右移。

### 2.2 整数表示

#### 2.2.1 整型数据类型

C 语言支持多种整型数据类型——表示有限范围的整数。C 语言标准定义了每种数据类型必须能够表示的最小的取值范围。

![csapp2.8](./_resource/csapp2.8.jpg)

![csapp2.9](./_resource/csapp2.9.jpg)

![csapp2.10](./_resource/csapp2.10.jpg)

#### 2.2.2 无符号数的编码

假设一共有 w 位，每个介于 0 ~ 2^w -1 之间的数都有唯一一个 w 位的值编码，即这个函数映射是一个双射。

#### 2.2.3 补码(two's-complement)编码

字的最高有效位解释为负权(negative weight)。

![csapp2.13](./_resource/csapp2.13.jpg)

C 语言标准并没有要求用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。

其他的表示方法有**反码(ones' complement)**和**原码(sign-magnitude)**，这两种表示方法都有一个奇怪的属性，就是对于数字 0 有两种不同的编码方式。

#### 2.2.4 有符号数和无符号数之间的转换

![csapp2.17](./_resource/csapp2.17.jpg)

#### 2.2.5 C 语言中的有符号数与无符号数

C 语言允许无符号数和有符号数之间的转换。转换的原则是底层的位表示保持不变。

![csapp2.18](./_resource/csapp2.18.jpg)

#### 2.2.6 扩展一个数字的位表示

将一个无符号数转换为一个更大的数据类型，我们只需要简单地在表示的开头添加 0，这种运算称为**零扩展(zero extension)**。将一个补码数字转换为一个更大的数据类型可以执行**符号扩展(sign extension)**，规则是在表示中添加最高有效位的值的副本。

#### 2.2.7 截断数字

截断一个数字可能会改变它的值——溢出的一种形式。

#### 2.2.8 关于有符号树与无符号数的建议

有符号数叨无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换细微差别的错误很难被发现。因为这种强制类型转换是在代码中没有明确指示的情况下发生的，程序员经常忽视了它的影响。

避免这类错误的一种方法就是绝不使用无符号数。实际上，除了 C 以外，很少有语言支持无符号整数。

### 2.3 整数运算

理解计算机运算的细微之处能够帮助程序员编写更可靠的代码。

#### 2.3.1 无符号加法

考虑两个非负整数 x 和 y，满足 0 ≤ x, y ≤ 2^w - 1。每个数都能表示为 w 位无符号数字。如果计算它们的和，我们就有一个可能的范围 0 ≤ x + y ≤ 2^(w+1) - 2，表示这个和可能需要 w + 1位。无符号运算可以被视为一种模运算形式。

#### 2.3.2 补码加法

必须确定当结果太大(为正)或者太小(为负)时，应该做些什么。

![csapp2.24](./_resource/csapp2.24.jpg)

#### 2.3.3 补码的非

略

#### 2.3.4 无符号乘法

略

#### 2.3.5 补码乘法

![csapp2.26](./_resource/csapp2.26.jpg)

#### 2.3.6 乘以常数

在大多数机器上，整数乘法指令相当慢，需要 10 个或者更多的时钟周期，然而其他整数运算(例如加法、减法、位级运算和移位)只需要 1 个时钟周期。因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。

例如，假设一个程序包含表达式 x * 14。利用等式 14 = 2^3 + 2^2 + 2^1，编译器会将乘法重写为 (x << 3) + (x << 2) + (x << 1)，实现了将一个乘法替换为三个移位和两个加法。更好的方法是 14 = 2^4 - 2^1，将乘法重写为(x << 4) - (x << 1)，这时只需要两个移位和一个减法。

#### 2.3.7 除以 2 的幂

在大多数机器上，整数除法要比整数乘法更慢——需要 30 个或者更多的周期。除以 2 的幂也可以用移位运算右移来实现，无符号和补码数分别使用逻辑移位和算术移位来达到目的。

#### 2.3.8 关于整数运算的最后思考

计算机执行“整数”运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。补码表示提供了一种既能表示负数也能表示正数的灵活方法，同时使用了与执行无符号算术相同的位级实现。

### 2.4 浮点数

浮点表示对形如 V = x * 2^y 的有理数进行编码，IEEE 标准 754 规定了如何表示浮点数及其运算。

#### 2.4.1 二进制小数

![csapp2.30](./_resource/csapp2.30.jpg)

增加二进制表示的长度可以提高表示的精度。

#### 2.4.2 IEEE 浮点表示

用 V = (-1)^s * M * 2^E 的形式来表示一个数：

+ 符号(sign) s决定这个数是负数(s=1)还是正数(s=0)，对于数值 0 的符号位解释作为特殊情况处理。
+ 尾数(significand) M 是一个二进制小数，它的范围是 1 ~ 2 - ε，或者是 0 ~ 1 - ε。
+ 阶码(exponent) E 的作用是对浮点数加权，这个权重是 2 的 E 次幂(可能是负数)

将浮点数的位表示划分为三个字段，分别对这些值进行编码：

+ 一个单独的符号位 s 直接编码符号 s。
+ k 位的阶码字段 exp = e(k-1)...e(1)e(0) 编码阶码 E。
+ n 位小数字段 frac = f(n-1)...f(1)f(0) 编码尾数 M，但是编码出来的值也依赖于阶码字段的值是否等于 0。

![csapp2.31](./_resource/csapp2.31.jpg)

![csapp2.32](./_resource/csapp2.32.jpg)

#### 2.4.3 数字示例

![csapp2.33](./_resource/csapp2.33.jpg)

![csapp2.34](./_resource/csapp2.34.jpg)

#### 2.4.4 舍入(rounding)

因为表示方法限制类浮点数的范围和精度，浮点运算只能近似地表示实数运算。因此，对于值 x，我们一般想用一种系统的方法，能够找到“最接近的”匹配值，这就是舍入运算的任务。

#### 2.4.5 浮点运算

浮点加法不具有结合性。浮点乘法在加法上不具备分配性。对于科学计算程序员和编译器编写者来说，这是很严重的问题，即使为了在三维空间中确定两条线是否交叉而写代码这样看上去很简单的任务，也可能成为一个很大的挑战。

#### 2.4.6 C 语言中的浮点数

float 和 double。在 int、float 和 double 格式之间进行强制类型转换时，程序改变数值和位模式的原则如下(假设 int 是 32 位的)：

+ 从 int 转换成 float，不会溢出，可能被舍入。
+ 从 int 或 float 转换成 double，能够保留精确的数值。
+ 从 double 转换成 float，可能溢出成为正无穷或负无穷，也可能被舍入。
+ 从 float 或者 double 转换成 int，值会向零舍入。例如 1.999 将被转换成 1。

### 2.5 小结

计算机将信息按位编码，通常组织成字节序列。用不同的编码方式表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节排序时使用不同的约定。

由于编码的长度有限，与传统整数和实数运算想必，计算机运算具有完全不同的属性。当超出表示范围时，有限长度能够引起数值溢出。当浮点数非常接近于 0.0，从而转换成零时，也会瞎溢。

必须非常小心地使用浮点运算，因为浮点运算只有有限的范围和精度，而且不遵守普遍的算术属性，比如结合性。

## 第 3 章：程序的机器级表示

计算机执行**机器代码**，用字节序列编码低级的操作，包括处理数据、管理存储器、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的原则、目标机器的指令集和操作系统遵循的规则，经过一系列的阶段产生机器代码。GCC C 语言汇编器以**汇编代码**的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后 GCC 调用**汇编器**和**链接器**，从而根据汇编代码生成可执行的机器代码。

### 3.1 历史观点

Intel 处理器系列俗称 x86，经历了一个长期的、不断进化的发展过程。

### 3.2 程序编码

假设一个 C 程序，有两个文件 p1.c 和 p2.c。我们在一台 IA32 机器上，用 Unix 命令行编译这些代码如下：

	unix> gcc -O1 -o p p1.c p2.c

编译选项 -O1 告诉编译器使用第一级优化。使用更高级别的优化产生的代码会严重改变形式，以至于产生的机器代码和初始源代码之间的关系非常难以理解。实际中，从得到的程序性能方面考虑，第二级优化(-O2)被认为是较好的选择。

实际上 gcc 命令调用了一系列程序，将源代码转化成可执行代码。首先，**C 预处理器**扩展源代码，插入所有用 #include 命令指定的文件，并扩展所有用 #define 声明指定的宏。然后，**编译器**产生两个源代码的汇编代码，名字分别为 p1.s 和 p2.s。接下来，**汇编器**将汇编代码转化成二进制目标代码，文件名为 p1.o 和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入地址的全局值。最后，**链接器**将两个目标代码文件与实现库函数(例如 printf )的代码合并，并产生最终的可执行代码文件 p。

#### 3.2.1 机器级代码

对于机器级变成来说，有两种抽象非常重要。第一种是机器级程序的格式和行为，定义为指**令集体系结构(Instruction set architecture, ISA)**，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。第二种抽象是，机器级程序使用的存储器地址是虚拟地址，提供的存储器模型看上去是一个非常大的字节数组。

在整个编译过程中，编译器会完成大部分的工作，将把用 C 语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码非常接近于机器代码，与机器代码的二进制格式相比，汇编代码有一个主要特点，即它用可读性更好的文本格式来表示。能够理解汇编代码和它与原始的 C 代码的联系，是理解计算机如何执行程序的关键一步。

IA32 机器代码和原始的 C 代码差别非常大。一些通常对 C 语言程序员隐藏的处理器状态是可见的：

+ **程序计数器**(PC，用 %eip 表示)指示将要执行的下一条指令在存储器中的地址。
+ 整数**寄存器**文件包含 8 个命名的位置，分别存储 32 位的值。这些寄存器可以存储地址(对应于 C 语言的指针)或证书数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器则用来保存临时数据。
+ 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化。
+ 一组浮点寄存器存放浮点数据。

汇编代码不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和整数。

程序存储器(program memory)包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的存储器块。

一条指令只执行一个非常基本的操作。例如，将存放在寄存器中的两个数字相加，在存储器和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现(像算术表达式求值、循环或过程调用和返回这样的)程序结构。

#### 3.2.2 代码示例

假设我们写了一个 C 语言代码文件 code.c，内容如下：

	int accum = 0;

	int sum(int x, int y){
    	int t = x + y;
    	accum += t;
    	return t;
	}

在命令行上使用 `-S` 选项，就能得到 C 语言编译器产生的汇编代码：

	unix> gcc -O1 -S code.c

GCC 会运行编译器，产生一个汇编文件 code.s，但是不做其他进一步的工作。如果我们使用 `-c` 命令行选项，GCC 会编译并汇编该代码：

	unix> gcc -O1 -c code.c

这就会产生目标代码文件 code.o，它是二进制格式，无法直接查看。机器实际执行的程序只是对一系列指令进行编码的字节序列。及其对产生这些指令的源代码几乎一无所知。

#### 3.2.3 关于格式的注释

所有以 `.` 开头的行都是指导汇编器和链接器的命令，我们通常可以忽略这些行。

#### 3.2.4 数据格式

由于是从 16 位体系结构扩展成 32 位的，Intel 用术语 word 表示 16 位数据类型。因此，称 32 位数为 double words，称 64 位数为 quad words。后面遇到的大多数指令都是对 word 或者 double words 操作的。

![csapp3.1](./_resource/csapp3.1.jpg)

### 3.4 访问信息

一个 IA32 CPU 包含一组 8 个存储 32 位值的寄存器。这些寄存器用来存储整数数据和指针。它们的名字都以 %e 开头，不过它们都另有特殊的名字。

![csapp3.2](./_resource/csapp3.2.jpg)

对前三个寄存器(%eax, %ecx, %edx)的保存和恢复惯例不同于接下来的三个寄存器(%ebx, %edi, %esi)。最后两个寄存器(%ebp, %esp)保存着指向程序栈中重要位置的指针。只有根据栈管理的标准惯例才能修改这两个寄存器中的值。

字节操作指令可以独立地读写前 4 个寄存器的 2 个低位字节。8086 中提供这样的特性是为了兼容 8008 和 8080。当一条字节指令更新这些单字节“寄存器元素”中的一个时，余下的 3 个字节不会改变。

#### 3.4.1 操作数指示符

大多数指令有一个或多个**操作数(operand)**，指示出执行一个操作中要引用的源数据值，以及放置结果的目标位置。操作数可能被分为三种类型：

1. 立即数(immediate)，也就是常数值
2. 寄存器(register)，表示某个寄存器的内容
3. 存储器(memory)引用，它会根据计算出来的地址访问某个存储器位置

![csapp3.3](./_resource/csapp3.3.jpg)

#### 3.4.2 数据传送指令

将数据从一个位置复制到另一个位置的指令是最频繁使用的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条指令才能完成的功能。

![csapp3.4](./_resource/csapp3.4.jpg)

### 3.5 算术和逻辑操作

给出的每个指令类都有对字节、字和双字数据进行操作的指令。这些操作被分为四组：加载有效地址、亿元操作、二元操作和移位。

#### 3.5.1 加载有效地址

加载有效地址(load effective address)指令 leal 实际上是 movl 指令的变形。它的指令形式是从存储器读数据到寄存器，但实际上它根本就没有引用存储器。它的第一个操作数看上去是一个存储器引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。

![csapp3.7](./_resource/csapp3.7.jpg)

#### 3.5.2 一元操作和二元操作

一元操作：一个操作数既是源又是目的

二元操作：第二个操作数既是源又是目的

#### 3.5.3 移位操作

先给出移位量，第二项给出的是要移位的位数，可以进行算术和逻辑右移。

#### 3.5.4 讨论

![csapp3.8](./_resource/csapp3.8.jpg)

#### 3.5.5 特殊的算术操作

![csapp3.9](./_resource/csapp3.9.jpg)

### 3.6 控制

机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。

#### 3.6.1 条件码

除了整数寄存器，CPU 还维护着一组单个 bit 的**条件码(condition code)** 寄存器，他们描述了最近的算术或逻辑操作的属性。

![csapp0.4](./_resource/csapp0.4.jpg)

![csapp3.10](./_resource/csapp3.10.jpg)

#### 3.6.2 访问条件码

条件码通常不会直接读取，常用的使用方法有三种：

1. 可以根据条件码的某个组合，将一个字节设置为 0 或者 1
2. 可以条件跳转到程序的某个其他的部分
3. 可以有条件地传送数据

![csapp3.11](./_resource/csapp3.11.jpg)

#### 3.6.3 跳转指令及其编码

跳转(jump)指令会导致执行切换到程序中的一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号(label)指明。

![csapp3.12](./_resource/csapp3.12.jpg)

#### 3.6.4 翻译条件分支

将条件表达式和语句从 C 语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转

![csapp3.13](./_resource/csapp3.13.jpg)

#### 3.6.5 循环

汇编中没有循环结构的指令存在，可以用条件测试和跳转组合起来实现循环的效果。大多数汇编器根据一个循环的 do-while形式来产生循环代码，即使在实际程序中这种形式用得相对较少。

![csapp3.14](./_resource/csapp3.14.jpg)

![csapp3.15](./_resource/csapp3.15.jpg)

#### 3.6.6 条件传送指令

实现条件操作的传统方法是利用控制的条件转移。当条件满足时，程序沿着一条执行路径进行，反之走另一条路径。这种机制简单而通用，但是在现代处理器上，它可能会非常低效率。

数据的条件转移是一种替代的策略。这种方法先计算一个条件操作的两种结果，然后再根据条件是否满足从而选取一个。只有在一些受限制的情况下，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它。条件传送指令更好地匹配了现代处理器的性能特征。

![csapp3.16](./_resource/csapp3.16.jpg)

这个机制和分支预测紧密相关。

![csapp3.17](./_resource/csapp3.17.jpg)

#### 3.6.7 switch 语句

switch 语句可以根据一个整数索引值进行多重分支(multi-way branching)。不仅提高了 C 代码的可读性，而且通过使用**跳转表(jump table)**和使用一组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。GCC 根据开关情况的数量和开关情况值的 sprsity 来翻译开关语句。

![csapp3.18](./_resource/csapp3.18.jpg)

### 3.7 过程

一个过程调用包括将数据和控制从代码的一部分传递到另一部分。另外，它还必须在进入时为过程的局部变量分配空间，并在退出时释放这些空间。大多数机器，包括 IA32，只提供转移控制到过程和从过程转移出控制这种简单的指令。数据传递、局部变量的分配和释放通过操纵程序栈来实现。

#### 3.7.1 栈帧结构

IA32 程序用程序栈来支持过程调用。机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后回复，以及本地存储。为单个过程分配的那部分栈称为**栈帧(stack frame)**。

![csapp3.21](./_resource/csapp3.21.jpg)

假设过程 P(调用者)调用过程 Q(被调用者)，则 Q 的参数放在 P 的栈帧中。另外，当 P 调用 Q 时，P 中的**返回地址**被压入栈中，形成 P 的栈帧的末尾。返回地址就是当程序从 Q 返回时应该继续执行的地方。

#### 3.7.2 转移控制

![csapp3.22](./_resource/csapp3.22.jpg)

#### 3.7.3 寄存器使用惯例

程序寄存器组是唯一能够被所有过程共享的资源。虽然在给定时刻只能有一个过程是活动的，但是我们必须保证当一个过程调用另一个过程时，被调用者不会覆盖某个调用者稍后会使用的寄存器的值。

根据惯例，寄存器 %eax、%edx、%ecx 被划分为**调用者保存**寄存器。当过程 P 调用 Q 时，Q 可以覆盖这些寄存器，而不会破坏任何 P 所需要的数据。另一方面， 寄存器 %ebx、%esi、%edi 被划分为**被调用者保存**寄存器。

#### 3.7.4 过程示例

![csapp3.24](./_resource/csapp3.24.jpg)

#### 3.7.5 递归过程

![csapp3.25](./_resource/csapp3.25.jpg)

![csapp3.27](./_resource/csapp3.27.jpg)

### 3.8 数组分配和访问

C 语言实现数组的方式非常简单，因此很容易翻译成机器代码。C 语言一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译成地址计算。

优化编译器非常善于简化数组索引所使用的地址计算。不过这使得 C 代码和它机器代码的翻译之间的对应关系有些难以理解。

#### 3.8.1 基本原则

对于数据类型 T 和整型常数 N，声明如下：

	T A[N];

它有两个效果。首先，它在存储器中分配一个 L*N 字节的连续区域；这里 L 是数据类型 T 的大小(单位为字节)。可以用从 0 到 N-1 之间的整数索引来访问数组元素。数组元素 i 会被存放在地址为 xa + L * i 的地方(xa 为指向数组开头的指针)

![csapp0.5](./_resource/csapp0.5.jpg)

#### 3.8.2 指针运算

C 语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果 p 是一个指向类型为 T 的数据的指针，p 的值为 xp，那么表达式 p+i 的值为 xp+L*i，这里 L 是数据类型 T 的大小。

![csapp0.6](./_resource/csapp0.6.jpg)

#### 3.8.3 嵌套的数组

	int A[5][3];

等价于下面的声明

	typedef int row3_t[3];
	row3_t A[5];

数据类型`row3_t`被定义为一个 3 个整数的数组。数组 A 包含 5 个这样的元素，每个元素需要 12 个字节来存储 3 个整数。整个数组的大小就是 4x5x3=60 字节。

![csapp0.7](./_resource/csapp0.7.jpg)

#### 3.8.4 定长数组

C 语言编译器能够优化定长多维数组上的操作代码。

![csapp3.28](./_resource/csapp3.28.jpg)

#### 3.8.5 变长数组

![csapp3.29](./_resource/csapp3.29.jpg)

### 3.9 异质的数据结构

C 语言提供了两种结合不同类型的对象来创建数据类型的机制：**结构(structure)**，用关键字`struct`声明，将多个对象集合到一个单位中；**联合(union)**，用关键字`union`声明，允许用几种不同的类型来引用一个对象。

#### 3.9.1 结构

创建一个数据类型，将可能不同类型的对象聚合到一个对象中。结构的各个组成部分用名字来引用。类似于数组的实现，结构的所有组成部分都存放在存储器中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段(field)的字节偏移。它以这些偏移作为存储器引用指令中的位移，从而产生对结构元素的引用。

#### 3.9.2 联合

提供了一种方式，能够规避 C 语言的类型系统，允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样，只不过语义相差比较大。它们是用不同的字段来引用相同的存储器块。

#### 3.9.3 数据对齐

许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值 K(通常是 2、4、8)。这种对齐限制简化了形成处理器和存储器系统之间接口的硬件设计

**强制对齐的情况**

对于大多数 IA32 指令来说，保持数据对齐能够提高效率，但是它不会影响程序的行为。另一方面，如果数据未对齐，有些实现多媒体操作的 SSE 指令就无法正确工作。

### 3.10 综合：理解指针

指针是 C 语言的一个重要特征。它们以一种统一方式，对不同数据结构中的元素产生引用。这里介绍一些指针和它们映射到机器代码的关键原则。

+ **每个指针都对应一个类型。**这个类型表明指针指向哪一类对象。
+ **每个指针都有一个值。**这个值是某个指定类型对象的地址。特殊的 NULL(0) 值表示该指针没有指向任何地方
+ **指针用 & 运算符创建。**这个运算符可以应用到任何 lvalue 类的 C 表达式上。
+ **操作符用于指针的间接引用。**其结果是一个值，它的类型与该指针的类型相关。间接引用是通过存储器引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取。
+ **数组与指针紧密联系。**一个数组的名字可以像一个指针变量一样引用(但是不能修改)。数组引用与指针运算和间接引用有一样的效果。数组引用和指针运算都需要用对象大小对偏移量进行伸缩。
+ **将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。**强制类型转换的一个效果是改变指针运算的伸缩。来看一个例子，如果 p 是一个 char* 类型的指针，那么表达式(int*)p+7 计算为 p+28, 而(int*)(p+7)计算为 p+7。
+ 指针也可以指向函数。这提供了一个很强大的存储和向代码传递引用的功能，这些引用可以被程序的某个其他部分调用。

**函数指针**

假如我们有一个函数`int fun(int x, int *p)`，然后我们可以声明一个指针`fp`，将它赋值为这个函数：

	(int)(*fp)(int, int *);
	fp = fun;

然后用以下真真来调用这个函数

	int y = 1;
	int result = fp(3, &y);

### 3.11 应用：使用 GDB 调试器

启动 GDB:

	unix> gdb prog

### 3.12 存储器的越界引用和缓冲区溢出

C 对于数组引用不进行任何边界检查，而局部变量和状态信息，都存放在栈中。这两种情况结合到一起就可能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行 ret 指令时，就会出现很严重的错误。

缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。通常，输入和程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为**攻击代码(exploit code)，另外还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么执行 ret 指令的效果就是跳转到攻击代码。

一种攻击形式，攻击代码会使用系统调用启动一个外壳程序，给攻击者提供一组操作系统函数。另一种攻击形式是，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行 ret 指令，(表面上)正常返回给调用者。

**对抗缓冲区溢出攻击**

1.**栈随机化**

**为了在系统中插入攻击代码，攻击者不但要插入代码，还需要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。在过去，程序的栈地址非常容易预测。对于所有运行同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相当固定的。用传染病来打比方，许多系统都容易受到同一种病毒的攻击，这种现象常称作**安全单一化(security monoculture)**。

**栈随机化**的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。实现的方式是：程序开始时，在栈上分配一段 0-n 字节之间的随机大小的空间。

在 Linux 系统中，栈随机化已经变成了标准行为。它是更大一类技术中的一种，这类技术称为**地址空间布局随机化(Address-Space Layout Randomization)，或者简称 ASLR。

然而一个执着的攻击者总是能够用蛮力克服随机化，他可以反复地用不同的地址进行攻击。一种常见的把戏就是在实际的攻击代码前插入很长一段的 nop 指令。执行这种指令除了对程序计数器加一，使指针指向下一条指令之外，没有任何的效果。只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序列，到达攻击代码。这个序列常用的术语是“空操作雪橇”(nop sled)。

2.**栈破坏检测**

**栈保护者(stack protector)**机制，用来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的__金丝雀(canary)__值，也称为__哨兵值(guard value)__，如下图所示。这个值是在程序每次运行时随机产生的，因此，攻击者没有简单的办法能够知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了。如果是，那么程序异常终止。

3.__限制可执行代码区域__

消除攻击者向系统中插入可执行代码的能力，只有保存编译器产生的代码的那部分妇女初期才是可执行的，其他部分可以被限制为只允许读和写

![csapp3.33](./_resource/csapp3.33.jpg)

### 3.13 x86-64: 将 IA32 扩展到 64 位

IA32 的 32 位字长已经成为限制微处理器能力不断增长的主要因素。最重要的是，机器的字长定义了程序能够使用的虚拟地址范围，32 位字长就是 4GB 虚拟地址空间。现在机器很容易就可以配置 4G 以上 RAM，但是系统却不能有效利用它。

Intel 和 AMD 提供的新硬件和以这些为目标的 GCC 新版本的组合，使得 x86-64 代码与为 IA32 机器生成的代码有极大的不同。主要特性如下：

+ 指针和长整数是 64 位长。整数运算支持 8/16/32/64 位数据类型
+ 通用目的寄存器组从 8 个扩展到 16 个
+ 许多程序状态都保存在寄存器中，而不是栈上
+ 如果可能，条件操作用条件传送指令实现，会得到比传统分支代码更好的性能
+ 浮点操作用面向寄存器的指令集来实现

![csapp3.34](./_resource/csapp3.34.jpg)

### 3.14 浮点程序的机器级表示

我们把存储模型、指令和传递规则的组合称为机器的__浮点体系结构__。由于 x86 处理器有很长的发展演变历史，它提供了多种浮点体系结构，目前有两种还在使用：x87 和 SSE

### 3.15 小结

机器级程序和它们的汇编代码表示，与 C 程序的差别很大。在汇编语言程序中，各种数据类型之间的差别很小。程序是以指令序列来表示的，每条指令都完成一个单独的操作。部分程序状态，如寄存器和运行时栈，对程序员来说是直接可见的。

C 语言中缺乏边界检查，使得许多程序容易出现缓冲区溢出。虽然最近的运行时系统提供了安全保护，而且编译器帮助使得程序更加安全，但是这已经使许多系统容易收到入侵者的恶意攻击。

## 第 4 章：处理器体系结构

现代微处理器可以称得上时人类创造的最复杂的系统之一。一个处理器支持的指令和指令的字节级编码称为它的__指令集体系结构(Instruction-Set Architecture, ISA)__。不同的处理器家族，有不同的 ISA。一个程序编译成在一种机器上运行。

注：这一章偏硬件实现部分将较为简略，具体参看原书。

### 4.1 Y86 指令集体系结构

定义一个指令集体系结构，包括定义各种状态元素、指令集和它们的编码、一组编程规范和异常事件处理。

#### 4.1.1 程序员可见的状态

如下图所示，Y86 程序中的每条指令都会读取或修改处理器状态的某些部分，这称为__程序员可见状态__。在处理器视线中，只要我们保证机器级程序能够访问程序员可见状态，就不需要完全按照 ISA 隐含的方式来表示和组织这个处理器状态。

![csapp4.1](./_resource/csapp4.1.jpg)

Y86 处理器有 8 个程序寄存器(每个存储一个字，%esp 被入栈、出栈、调用和返回指令作为栈指针)，3 个一位的条件码(保存最近的算术或逻辑指令所造成影响的有关信息)，程序计数器 PC 存放当前正在执行指令的地址。

存储器，从概念上说就是一个很大的数组，保存这程序和数据。 Y86 程序使用__虚拟地址__来引用存储器位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或__物理地址__，指明数据实际保存在存储器中的哪个地方。

状态码 Stat 表明程序执行的总体状态，它会指示是正常运行，还是出现了某种异常。

#### 4.1.2 Y86 指令

![csapp4.2](./_resource/csapp4.2.jpg)

具体说明

+ 4 个 movl 相关指令，显式指明源和目的的格式。源可以是立即数(i)、寄存器(r)或存储器(m)。指令名字的第一个字母表明了源的类型，第二个字母指明了目的类型
+ 4 个整数操作指令，即上图的 OPl，它们是 addl、subl、andl 和 xorl。它们只对寄存器数据进行操作，并设置 3 个条件码 ZF、SF 和 OF(零、符号和一处)
+ 7 个跳转指令，即上图的 jXX，它们是 jmp、jle、jl、je、jne、jge 和 jg。根据分支指令的类型和条件码的设置来选择分支
+ 6 个条件传送指令，即上图的 cmovXX：cmovle、cmovl、cmove、cmovne、cmovge 和 cmovg，只有当条件码满足所需要的约束时，才会更新目的寄存器的值
+ call 指令将返回地址入栈，然后跳到目的地址。ret 指令从这样的过程调用中返回
+ pushl 和 popl 指令实现了入栈和出栈
+ halt 指令停止指令的执行

#### 4.1.3 指令编码

每条指令需要 1~6 个字节不等，每条指令的第一个字节表明指令的类型。这个字节分为两个部分，每部分 4 位：高 4 位是__代码(code)__部分，低 4 位是__功能(function)部分__。

![csapp4.3](./_resource/csapp4.3.jpg)

CISC vs RISC

![csapp0.8](./_resource/csapp0.8.jpg)

### 4.2 逻辑设计和硬件控制语言 HCL

在硬件设计中，用电子电路来计算来计算对位进行运算的函数，以及在各种存储器元素中存储位。大多数现代电路技术都用信号线上的高电压或低电压来表示不同的位值。

#### 4.2.1 逻辑门

逻辑门是数字电路的基本计算元素。它们产生的输出，等于它们输入位值的某个布尔函数。

#### 4.2.2 组合电路和 HCL 布尔表达式

将很多的逻辑门组合成一个网，就能构建计算块(computational block)，称为__组合电路(combinational circuits)__。构建这些网有两条限制：

+ 两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障
+ 这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。

#### 4.2.3 字级的组合电路和 HCL 整数表达式

通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。

### 4.3 Y86 的顺序实现

将处理组织成阶段

取指(fetch)、译码(decode)、执行(execute)、访存(memory)、写回(write back)、更新 PC(PC update)

### 4.4 流水线的通用原理

参考 Foundation of Computer Architecture，此略

### 4.5 Y86 的流水线实现

具体实现不要在意这些细节，此略

### 4.6 小结

有关处理器设计的几个重要经验：

+ 管理复杂性是首要问题。想要优化使用硬件资源，在最小的成本下获得最大的性能
+ 我们不需要直接实现 ISA
+ 硬件设计人员必须非常谨慎小心

## 第 5 章：优化程序性能

> 
